--- FILE: ./app/c402/page.tsx ---

// app/c402/page.tsx
"use client";

import Link from "next/link";
import { useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import { supabase } from "@/lib/supabaseClient";
import * as api from "@/lib/api";
import { usePresence } from "@/context/PresenceContext";

export default function DashboardPage() {
  const router = useRouter();
  const [token, setToken] = useState<string | null>(null);
  const [me, setMe] = useState<any>(null);
  const [rooms, setRooms] = useState<any[]>([]);
  const [allRooms, setAllRooms] = useState<any[]>([]);
  const [msg, setMsg] = useState("");
  const [newRoom, setNewRoom] = useState({ name: "", color_id: 1 });

  const { wsReady, subscribePresence, unsubscribePresence, onlineUsers } =
    usePresence();

  // 1. 認証トークン取得
  useEffect(() => {
    supabase.auth.getSession().then(({ data }) => {
      setToken(data.session?.access_token ?? null);
    });
  }, []);

  // 2. ユーザー情報セットアップ
  useEffect(() => {
    if (!token) return;
    (async () => {
      try {
        const u = await api.getMe(token);
        setMe(u);
      } catch {
        const { data } = await supabase.auth.getUser();
        const user = data.user!;
        const u = await api.createUser(token, {
          display_name:
            user.user_metadata?.full_name ||
            user.user_metadata?.name ||
            user.email!.split("@")[0],
          email: user.email!,
          icon_url: user.user_metadata?.avatar_url ?? "",
        });
        setMe(u);
      }
    })();
  }, [token]);

  // app/c402/page.tsx
  useEffect(() => {
    if (!token) return;

    const ws = new WebSocket(
      `${process.env.NEXT_PUBLIC_WS_URL || "ws://localhost:8000/ws"}?token=${token}`,
    );
    ws.onmessage = (e) => {
      const ev = JSON.parse(e.data);
      if (
        ev.type === "join_request" ||
        ev.type === "join_request_cancelled" ||
        ev.type === "join_approved"
      ) {
        setMsg((m) => m + "x");
      }
    };
    return () => ws.close();
  }, [token]);
  // 3. 自分の参加ルーム一覧取得
  useEffect(() => {
    if (!token) return;
    api.listRooms(token).then(setRooms);
  }, [token, msg]);

  // 4. 全ルーム一覧取得（参加申請用）
  useEffect(() => {
    if (!token) return;
    api.getAllRooms(token).then(setAllRooms);
  }, [token, msg]);

  // 5. rooms の変化に合わせて presence を subscribe/unsubscribe
  useEffect(() => {
    rooms.forEach((r) => subscribePresence(r.room_id));
    return () => {
      rooms.forEach((r) => unsubscribePresence(r.room_id));
    };
  }, [rooms, subscribePresence, unsubscribePresence]);

  if (!token || !me)
    return <p className="text-center mt-20 text-gray-400">Loading…</p>;

  return (
    <div className="min-h-screen bg-gray-900 text-gray-100">
      <header className="flex justify-between items-center p-6 border-b border-gray-700">
        <h1 className="text-2xl font-bold">
          Welcome, {me.display_name}
          {!wsReady && (
            <span className="ml-2 text-sm text-yellow-400 animate-pulse">
              Connecting…
            </span>
          )}
        </h1>
        <button
          onClick={async () => {
            await supabase.auth.signOut();
            router.replace("/");
          }}
          className="px-4 py-2 bg-red-600 hover:bg-red-700 rounded transition"
        >
          Logout
        </button>
      </header>

      <main className="max-w-3xl mx-auto p-6 space-y-8">
        {/* 新規ルーム作成 */}
        <section className="bg-gray-800 p-4 rounded">
          <h2 className="text-lg font-semibold mb-3">新規ルーム作成</h2>
          <div className="flex gap-2">
            <input
              placeholder="ルーム名"
              value={newRoom.name}
              onChange={(e) => setNewRoom({ ...newRoom, name: e.target.value })}
              className="flex-1 p-2 bg-gray-700 border border-gray-600 rounded"
            />
            <input
              type="number"
              min={1}
              max={12}
              value={newRoom.color_id}
              onChange={(e) =>
                setNewRoom({ ...newRoom, color_id: Number(e.target.value) })
              }
              className="w-20 p-2 bg-gray-700 border border-gray-600 rounded"
            />
            <button
              onClick={async () => {
                if (!newRoom.name) {
                  alert("ルーム名を入力してください");
                  return;
                }
                await api.createRoom(token, newRoom);
                setNewRoom({ name: "", color_id: 1 });
                setMsg("new-room");
              }}
              className="px-4 py-2 bg-green-600 hover:bg-green-700 rounded transition"
            >
              作成
            </button>
          </div>
        </section>

        {/* 参加可能ルーム */}
        <section>
          <h2 className="text-xl font-semibold mb-3">参加可能なルーム</h2>
          <div className="space-y-2">
            {allRooms
              .filter((r) => !rooms.some((x) => x.room_id === r.room_id))
              .map((r) => {
                const pending = r.pending_members?.some(
                  (m: any) => m.uid === me.uid,
                );
                return (
                  <div
                    key={r.room_id}
                    className="flex justify-between items-center p-3 bg-gray-800 rounded"
                  >
                    <div>
                      <strong>{r.name}</strong>{" "}
                      <span className="text-gray-400">({r.room_id})</span>
                    </div>
                    {pending ? (
                      <button
                        onClick={async () => {
                          await api.cancelJoinRequest(token, r.room_id);
                          setMsg("cancel-req");
                        }}
                        className="px-3 py-1 bg-yellow-600 hover:bg-yellow-700 rounded"
                      >
                        申請キャンセル
                      </button>
                    ) : (
                      <button
                        onClick={async () => {
                          await api.joinRoom(token, r.room_id);
                          setMsg("join-req");
                        }}
                        className="px-3 py-1 bg-blue-600 hover:bg-blue-700 rounded"
                      >
                        参加申請
                      </button>
                    )}
                  </div>
                );
              })}
          </div>
        </section>

        {/* あなたのルーム一覧 */}
        <section>
          <h2 className="text-xl font-semibold mb-3">あなたのルーム</h2>
          <div className="space-y-2">
            {rooms.map((r) => {
              const count = onlineUsers[r.room_id]?.size ?? 0;
              return (
                <Link
                  key={r.room_id}
                  href={`/rooms/${r.room_id}`}
                  className="flex justify-between items-center p-3 bg-gray-800 rounded hover:bg-gray-700 transition"
                >
                  <div className="flex items-center gap-2">
                    <span className="font-medium text-white">
                      {r.name}{" "}
                      <span className="text-gray-400">({r.room_id})</span>
                    </span>
                    {r.pending_members?.length > 0 && (
                      <span
                        title="参加申請があります"
                        className="w-2 h-2 bg-yellow-400 rounded-full animate-pulse"
                      />
                    )}
                  </div>
                  <div className="flex items-center gap-1">
                    {count > 0 && (
                      <span
                        className="w-3 h-3 bg-blue-400 rounded-full animate-pulse"
                        title={`${count} online`}
                      />
                    )}
                    <span className="text-gray-400 text-sm">{count}</span>
                  </div>
                </Link>
              );
            })}
            {rooms.length === 0 && (
              <p className="text-gray-500">まだ参加中のルームはありません。</p>
            )}
          </div>
        </section>
      </main>
    </div>
  );
}


--- FILE: ./app/globals.css ---

@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}

/* globals.css */
/* globals.css */
.material-symbols-outlined {
  font-variation-settings:
    'FILL' 0,
    'wght' 400,
    'GRAD' 0,
    'opsz' 24;
  /* 必要に応じて調整してください */
}
/* スクロールバー非表示 */
.no-scrollbar::-webkit-scrollbar {
  display: none;
}
.no-scrollbar {
  -ms-overflow-style: none;
  scrollbar-width: none;
}


@layer utilities {
  .animate-spin-slow {
    animation: spin 3s linear infinite;
  }
}
@keyframes slide-in-right {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}


@layer utilities {
  .animate-slide-in-right {
    /* 初期状態で完全に透明に */
    opacity: 0;
    /* アニメーション再生後は最終状態を保持 */
    animation: slide-in-right 0.3s ease-out forwards;
    animation-fill-mode: both;
    will-change: transform, opacity;
  }
}
@keyframes slide-in-left {
  from {
    transform: translateX(-100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

.rotating-gradient {
  position: relative;
  overflow: hidden;
}
.rotating-gradient::before {
  content: '';
  position: absolute;
  inset: 0;
  z-index: 0;
  background: linear-gradient(0deg, #312e81 0%, #111827 100%);
  animation: gradient-rotate-real 32s linear infinite;
  will-change: transform;
}
@keyframes gradient-rotate-real {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
/* 子要素を前面に */
.rotating-gradient > * {
  position: relative;
  z-index: 1;
}


@keyframes coin-drop {
  0% {
    top: -80px;
    opacity: 0.95;
    transform: rotateZ(0deg) scale(1.05);
  }
  15% {
    opacity: 1;
  }
  85% {
    transform: rotateZ(var(--angle, 15deg)) scale(0.98);
    opacity: 1;
  }
  100% {
    top: 94vh;
    opacity: 0.77;
    transform: rotateZ(var(--angle, 25deg)) scale(0.97);
  }
}
.coin {
  position: absolute;
  top: -80px;
  z-index: 10;
  pointer-events: none;
  filter: drop-shadow(0 0 32px #facc1577);
  will-change: top, opacity, transform;
  opacity: 1;
}

body { font-family: Arial, sans-serif; background: #f8f9fa; margin: 0; }
input, button, select { font-size: 1rem; }
hr { margin: 2rem 0; }



--- FILE: ./app/layout.tsx ---

import "./globals.css";
export const metadata = {
  title: "Next.js",
  description: "Generated by Next.js",
};

// app/layout.tsx (または pages/_app.tsx)
import { PresenceProvider } from "@/context/PresenceContext";

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="ja">
      <body>
        <PresenceProvider>{children}</PresenceProvider>
      </body>
    </html>
  );
}


--- FILE: ./app/page.tsx ---

// page.tsx

"use client";
import { useRouter } from "next/navigation";
import { supabase } from "@/lib/supabaseClient";
import { useRef, useState, useEffect } from "react";
import AnimationSplash from "@/components/auth/AnimationSplash";

export default function AuthPage() {
  const router = useRouter();
  const [isAnimating, setIsAnimating] = useState(false);
  const animationTimer = useRef<NodeJS.Timeout | null>(null);

  const handleStart = async () => {
    const { data } = await supabase.auth.getUser();
    if (data?.user) {
      setIsAnimating(true);
      console.log("anima");
      animationTimer.current = setTimeout(() => {
        router.replace("/c402");
      }, 2000);
      return;
    }
    // 未認証ならGoogle認証フロー
    const { error } = await supabase.auth.signInWithOAuth({
      provider: "google",
      options: {
        redirectTo: process.env.NEXT_PUBLIC_SUPABASE_REDIRECT_URL,
      },
    });
    if (error) alert("Google sign-in error: " + error.message);
  };

  // cleanup: ページ離脱時にタイマー破棄
  useEffect(() => {
    return () => {
      if (animationTimer.current) clearTimeout(animationTimer.current);
    };
  }, []);

  return (
    <div className="min-h-screen bg-gray-900 flex flex-col">
      {isAnimating && <AnimationSplash />}
      {/* 左上アプリ名 */}
      <div className="absolute top-0 left-0 p-4 z-10">
        <span className="text-white font-bold text-lg">satopon</span>
      </div>
      <div className="flex flex-1 flex-col justify-center items-center z-0">
        <p className="text-gray-300 text-sm mb-12 text-center max-w-xs">
          Track and settle scores with friends—fast, simple, and fair.
        </p>
        <button
          onClick={handleStart}
          className="
            w-44 py-3
            bg-gradient-to-tr from-blue-500 to-indigo-600
            text-white font-semibold
            rounded-full shadow
            hover:from-blue-600 hover:to-indigo-700
            transition
            text-lg
          "
          disabled={isAnimating} // アニメ中は多重押し不可
        >
          Get Started
        </button>
        <div className="mt-2 text-xs text-gray-400 text-center">
          Start with Google
        </div>
      </div>
    </div>
  );
}


--- FILE: ./app/rooms/[roomId]/page.tsx ---

// app/rooms/[roomId]/page.tsx
"use client";

import { useParams, useRouter } from "next/navigation";
import { useEffect, useState } from "react";
import Link from "next/link";
import { supabase } from "@/lib/supabaseClient";
import * as api from "@/lib/api";
import { usePresence } from "@/context/PresenceContext";

export default function RoomPage() {
  const { roomId } = useParams<{ roomId: string }>();
  const router = useRouter();
  const [token, setToken] = useState<string | null>(null);
  const [me, setMe] = useState<any>(null);
  const [room, setRoom] = useState<any>(null);
  const [pointHistory, setPointHistory] = useState<any[]>([]);
  const [settleHistory, setSettleHistory] = useState<any[]>([]);
  const [msg, setMsg] = useState("");

  // ポイントラウンド用 state
  const [isRoundActive, setIsRoundActive] = useState(false);
  const [currentRoundId, setCurrentRoundId] = useState<string | null>(null);
  const [submittedBy, setSubmittedBy] = useState<Set<string>>(new Set());
  const [submissions, setSubmissions] = useState<Record<string, number>>({});
  const [finalTable, setFinalTable] = useState<Record<string, number> | null>(
    null,
  );
  const [approvedBy, setApprovedBy] = useState<Set<string>>(new Set());

  const [settleInput, setSettleInput] = useState({ to_uid: "", amount: 0 });
  // presence は context で管理
  const {
    wsReady,
    enterRoom,
    leaveRoom,
    subscribePresence,
    unsubscribePresence,
    onlineUsers: ctxOnlineUsers,
    onEvent,
  } = usePresence();

  // 1. トークン＆ユーザー取得
  useEffect(() => {
    supabase.auth.getSession().then(({ data }) => {
      setToken(data.session?.access_token ?? null);
    });
  }, []);

  useEffect(() => {
    if (!token) return;
    api
      .getMe(token)
      .then(setMe)
      .catch(() => router.replace("/"));
  }, [token, router]);
  // 3. roomData と history の初期取得だけ
  useEffect(() => {
    if (!token || !roomId) return;
    (async () => {
      try {
        const [roomData, ph, sh] = await Promise.all([
          api.getRoom(token, roomId),
          api.getPointHistory(token, roomId),
          api.getSettlementHistory(token, roomId),
        ]);
        setRoom(roomData);
        setPointHistory(ph);
        setSettleHistory(sh);
      } catch (err: any) {
        console.error("fetchAll error:", err);
        alert("データの取得に失敗しました。");
      }
    })();
  }, [token, roomId, msg]);

  // 3. PresenceContext を使って入退室管理
  useEffect(() => {
    if (!wsReady || !roomId) return;
    enterRoom(roomId);
    return () => {
      leaveRoom(roomId);
    };
  }, [wsReady, roomId, enterRoom, leaveRoom]);

  // 4. ポイント・精算イベントのみ拾う
  useEffect(() => {
    if (!roomId) return;
    const off = onEvent((ev) => {
      if (ev.room_id !== roomId) return;
      switch (ev.type) {
        case "point_round_started":
          setIsRoundActive(true);
          setCurrentRoundId(ev.round_id);
          setSubmittedBy(new Set());
          setSubmissions({});
          setFinalTable(null);
          setApprovedBy(new Set());
          break;
        case "point_submitted":
          setSubmissions((s) => ({ ...s, [ev.uid]: ev.value }));
          setSubmittedBy((s) => new Set(s).add(ev.uid));
          break;
        case "point_final_table":
          setIsRoundActive(false);
          setFinalTable(ev.table);
          break;
        case "point_approved":
          setApprovedBy((s) => new Set(s).add(ev.uid));
          break;
        case "point_round_cancelled":
          alert("ラウンド中止: " + ev.reason);
          setIsRoundActive(false);
          setSubmissions({});
          setSubmittedBy(new Set());
          break;
        default:
          // join_request, join_approved, settle_approved などは再フェッチ
          setMsg((m) => m + "x");
      }
    });
    return off;
  }, [onEvent, roomId]);

  if (!token || !me) {
    return <p className="text-center mt-20 text-gray-400">Loading…</p>;
  }
  if (!room) {
    return <p className="text-center mt-20 text-red-400">Room not found.</p>;
  }

  return (
    <div className="min-h-screen bg-gray-900 text-gray-100">
      <header className="flex items-center justify-between p-6 border-b border-gray-700">
        <h1 className="text-2xl font-bold">{room.name}</h1>
        <Link href="/c402" className="text-blue-400 hover:underline">
          ← ダッシュボードへ
        </Link>
      </header>
      <main className="max-w-3xl mx-auto p-6 space-y-8">
        {/* ルーム説明 */}
        {room.description && (
          <p className="text-gray-300">{room.description}</p>
        )}

        {/* メンバー一覧 & 退会 */}
        <section className="bg-gray-800 p-4 rounded">
          <h2 className="font-semibold mb-2">メンバー</h2>
          <div className="flex flex-wrap gap-2">
            {room.members.map((m: any) => {
              // PresenceContext 側の onlineUsers で判定
              const isOnline = ctxOnlineUsers[roomId]?.has(m.uid) ?? false;
              return (
                <span
                  key={m.uid}
                  className={`
                    px-3 py-1 rounded-full flex items-center gap-1
                    ${m.uid === me.uid ? "bg-blue-600" : "bg-gray-700"}
                    ${isOnline ? "ring-2 ring-green-400" : "opacity-60"}
                  `}
                >
                  {m.uid}
                  {isOnline && (
                    <span className="w-2 h-2 bg-green-400 rounded-full" />
                  )}
                </span>
              );
            })}
          </div>
          <button
            onClick={async () => {
              await api.leaveRoom(token, roomId);
              router.replace("/c402");
            }}
            className="mt-3 px-4 py-2 bg-red-600 hover:bg-red-700 rounded"
          >
            退会する
          </button>
        </section>

        {/* 参加申請中メンバー承認/拒否 (オーナー用) */}
        {room.created_by === me.uid && room.pending_members.length > 0 && (
          <section className="bg-gray-800 p-4 rounded">
            <h2 className="font-semibold mb-2">参加申請中</h2>
            {room.pending_members.map((p: any) => (
              <div
                key={p.uid}
                className="flex justify-between items-center mb-2"
              >
                <span>{p.uid}</span>
                <div className="flex gap-2">
                  <button
                    onClick={async () => {
                      await api.approveMember(token, roomId, p.uid);
                      setMsg("approved");
                    }}
                    className="px-3 py-1 bg-green-600 hover:bg-green-700 rounded"
                  >
                    承認
                  </button>
                  <button
                    onClick={async () => {
                      await api.rejectMember(token, roomId, p.uid);
                      setMsg((m) => m + "-rejected");
                    }}
                    className="px-3 py-1 bg-red-600 hover:bg-red-700 rounded"
                  >
                    拒否
                  </button>
                </div>
              </div>
            ))}
          </section>
        )}

        {/* ポイントラウンド */}
        <section className="bg-gray-800 p-4 rounded">
          <h2 className="font-semibold mb-3">ポイントラウンド</h2>
          {!isRoundActive && !finalTable && (
            <button
              onClick={() => api.startPointRound(token, roomId)}
              className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded"
            >
              ラウンド開始
            </button>
          )}
          {isRoundActive && (
            <div className="space-y-2">
              <p>提出状況:</p>
              {room.members.map((m: any) => (
                <div key={m.uid} className="flex justify-between">
                  <span>{m.uid}</span>
                  {submittedBy.has(m.uid) ? (
                    <span className="text-green-400">提出済</span>
                  ) : m.uid === me.uid ? (
                    <button
                      onClick={async () => {
                        const v = prompt("スコアを入力してください", "0");
                        if (v === null) {
                          await api.cancelPointRound(token, roomId, {
                            reason: "ユーザーキャンセル",
                          });
                          return;
                        }
                        const num = Number(v);
                        if (!isNaN(num)) {
                          await api.submitPoint(token, roomId, me.uid, num);
                        }
                      }}
                      className="px-3 py-1 bg-green-600 hover:bg-green-700 rounded"
                    >
                      提出
                    </button>
                  ) : (
                    <span className="text-gray-500">未提出</span>
                  )}
                </div>
              ))}
              {submittedBy.size === room.members.length && (
                <button
                  onClick={() => api.finalizePointRound(token, roomId)}
                  className="mt-3 px-4 py-2 bg-indigo-600 hover:bg-indigo-700 rounded"
                >
                  集計する
                </button>
              )}
            </div>
          )}
          {finalTable && (
            <div className="mt-4">
              <h3 className="font-medium mb-2">最終スコア表</h3>
              <div className="space-y-1">
                {Object.entries(finalTable).map(([uid, v]) => (
                  <div key={uid} className="flex justify-between">
                    <span>{uid}</span>
                    <span>{v}pt</span>
                  </div>
                ))}
              </div>
              <h4 className="mt-3 font-medium">承認状況</h4>
              <div className="space-y-1">
                {room.members.map((m: any) => (
                  <div key={m.uid} className="flex justify-between">
                    <span>{m.uid}</span>
                    {approvedBy.has(m.uid) ? (
                      <span className="text-green-400">承認済</span>
                    ) : (
                      m.uid === me.uid && (
                        <button
                          onClick={() =>
                            api.approvePoint(token, roomId, currentRoundId!)
                          }
                          className="px-3 py-1 bg-indigo-600 hover:bg-indigo-700 rounded"
                        >
                          承認
                        </button>
                      )
                    )}
                  </div>
                ))}
              </div>
            </div>
          )}
        </section>

        {/* ポイント履歴 */}
        <section className="bg-gray-800 p-4 rounded">
          <h2 className="font-semibold mb-2">ポイント履歴</h2>
          {pointHistory.length === 0 ? (
            <p className="text-gray-400">まだありません。</p>
          ) : (
            pointHistory.map((rec) => (
              <div key={rec.round_id} className="mb-3 p-3 bg-gray-700 rounded">
                <div className="flex justify-between">
                  <span>#{rec.round_id}</span>
                  <span className="text-gray-400 text-sm">
                    {new Date(rec.created_at).toLocaleString()}
                  </span>
                </div>
                <div className="grid grid-cols-2 gap-2 mt-2">
                  {rec.points.map((p: any) => (
                    <div key={p.uid} className="flex justify-between">
                      <span>{p.uid}</span>
                      <span>{p.value > 0 ? `+${p.value}` : p.value}pt</span>
                    </div>
                  ))}
                </div>
              </div>
            ))
          )}
        </section>

        {/* 精算 */}
        <section className="bg-gray-800 p-4 rounded">
          <h2 className="font-semibold mb-3">精算</h2>
          <div className="flex gap-2 mb-4">
            <select
              value={settleInput.to_uid}
              onChange={(e) =>
                setSettleInput((s) => ({ ...s, to_uid: e.target.value }))
              }
              className="flex-1 p-2 bg-gray-700 border border-gray-600 rounded"
            >
              <option value="">--相手選択--</option>
              {room.members
                .filter((m: any) => m.uid !== me.uid)
                .map((m: any) => (
                  <option key={m.uid} value={m.uid}>
                    {m.uid}
                  </option>
                ))}
            </select>
            <input
              type="number"
              value={settleInput.amount}
              onChange={(e) =>
                setSettleInput((s) => ({
                  ...s,
                  amount: Number(e.target.value),
                }))
              }
              className="w-24 p-2 bg-gray-700 border border-gray-600 rounded"
            />
            <button
              onClick={async () => {
                await api.settle(
                  token,
                  roomId,
                  settleInput.to_uid,
                  settleInput.amount,
                );
                setMsg("settled");
                setSettleInput({ to_uid: "", amount: 0 });
              }}
              className="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded"
            >
              リクエスト
            </button>
          </div>
          <h3 className="font-semibold mb-2">精算履歴</h3>
          {settleHistory.length === 0 ? (
            <p className="text-gray-400">まだありません。</p>
          ) : (
            settleHistory.map((s, i) => (
              <div
                key={i}
                className="flex justify-between items-center mb-2 p-3 bg-gray-700 rounded"
              >
                <span>
                  {s.from_uid} → {s.to_uid} : {s.amount}円 [
                  {s.approved ? "承認済" : "未承認"}]
                </span>
                {!s.approved && (
                  <button
                    onClick={async () => {
                      await api.approveSettlement(
                        token,
                        roomId,
                        s._id ?? s.settlement_id,
                      );
                      setMsg("approved-settle");
                    }}
                    className="px-3 py-1 bg-green-600 hover:bg-green-700 rounded"
                  >
                    承認
                  </button>
                )}
              </div>
            ))
          )}
        </section>
      </main>
    </div>
  );
}


--- FILE: ./components/auth/AnimationSplash.module.css ---

.splashRoot {
  position: fixed;
  inset: 0;
  background: #18181b;
  z-index: 100;
  overflow: hidden;
  pointer-events: none;
}
.satoponSpin {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  font-weight: 800;
  font-size: 2.5rem;
  color: white;
  animation: satopon-spin 1s linear infinite;
  user-select: none;
  pointer-events: none;
  letter-spacing: 0.06em;
  filter: drop-shadow(0 0 18px #facc15cc);
}
@keyframes satopon-spin {
  0% { transform: translate(-50%, -50%) rotate(0deg);}
  100% { transform: translate(-50%, -50%) rotate(360deg);}
}
.coin {
  position: absolute;
  top: -80px;
  z-index: 10;
  pointer-events: none;
  filter: drop-shadow(0 0 32px #facc1577);
  will-change: top, opacity, transform;
  opacity: 1;
}
@keyframes coin-drop {
  0% {
    top: -80px;
    opacity: 0.95;
    transform: rotateZ(var(--angle, 12deg)) scale(1.05);
  }
  15% {
    opacity: 1;
  }
  85% {
    transform: rotateZ(var(--angle, 18deg)) scale(0.98);
    opacity: 1;
  }
  100% {
    top: 94vh;
    opacity: 0.77;
    transform: rotateZ(var(--angle, 24deg)) scale(0.97);
  }
}


--- FILE: ./components/auth/AnimationSplash.tsx ---

import React from "react";
import styles from "./AnimationSplash.module.css";

type Coin = {
  id: number;
  left: number;
  size: number;
  delay: number;
  duration: number;
  angle: number;
};

export default function AnimationSplash({ show = true }: { show?: boolean }) {
  const coins = React.useMemo(() => {
    if (!show) return [];
    const arr: Coin[] = [];
    for (let i = 0; i < 48; ++i) {
      arr.push({
        id: i,
        left: 5 + Math.random() * 90,
        size: 42 + Math.random() * 36,
        delay: Math.random() * 0.4,
        duration: 0.85 + Math.random() * 0.65,
        angle: -24 + Math.random() * 48,
      });
    }
    return arr;
  }, [show]);
  if (!show) return null;
  return (
    <div className={styles.splashRoot}>
      <div className={styles.satoponSpin}>satopon</div>
      {coins.map((c) => (
        <div
          key={c.id}
          className={styles.coin}
          style={
            {
              left: `${c.left}%`,
              width: c.size,
              height: c.size,
              "--angle": `${c.angle}deg`,
              animation: `coin-drop ${c.duration}s ${c.delay}s cubic-bezier(0.28,0.7,0.45,1.12) forwards`,
            } as React.CSSProperties
          }
        >
          <svg viewBox="0 0 64 64" width={c.size} height={c.size}>
            <defs>
              <radialGradient id={`gold-main${c.id}`} cx="50%" cy="30%" r="60%">
                <stop offset="0%" stopColor="#f7fafc" />
                <stop offset="45%" stopColor="#facc15" />
                <stop offset="100%" stopColor="#b45309" />
              </radialGradient>
              <radialGradient id={`gold-edge${c.id}`} cx="50%" cy="70%" r="50%">
                <stop offset="0%" stopColor="#fef9c3" />
                <stop offset="100%" stopColor="#facc15" />
              </radialGradient>
              <filter
                id={`coin-glow${c.id}`}
                x="-30%"
                y="-30%"
                width="160%"
                height="160%"
              >
                <feGaussianBlur stdDeviation="5" result="blur" />
                <feMerge>
                  <feMergeNode in="blur" />
                  <feMergeNode in="SourceGraphic" />
                </feMerge>
              </filter>
            </defs>
            {/* コインふち */}
            <ellipse
              cx="32"
              cy="32"
              rx="30"
              ry="30"
              fill={`url(#gold-edge${c.id})`}
              filter={`url(#coin-glow${c.id})`}
              stroke="#fef9c3"
              strokeWidth="3"
            />
            {/* 本体 */}
            <ellipse
              cx="32"
              cy="32"
              rx="26"
              ry="26"
              fill={`url(#gold-main${c.id})`}
              stroke="#facc15"
              strokeWidth="1"
            />
            {/* 刻印 */}
            <text
              x="32"
              y="44"
              textAnchor="middle"
              fontSize="30"
              fontWeight="bold"
              fill="#fffbe7"
              stroke="#facc15"
              strokeWidth="1.2"
              filter={`url(#coin-glow${c.id})`}
              style={{
                textShadow: "0 1px 6px #fbbf24, 0 2px 12px #fbbf24cc",
              }}
            >
              S
            </text>
          </svg>
        </div>
      ))}
    </div>
  );
}


--- FILE: ./context/PresenceContext.tsx ---

// src/context/PresenceContext.tsx
"use client";

import React, {
  createContext,
  useContext,
  useEffect,
  useRef,
  useState,
  useCallback,
  PropsWithChildren,
} from "react";
import * as api from "@/lib/api";
import { supabase } from "@/lib/supabaseClient";

type Event =
  | { type: "user_entered"; room_id: string; uid: string }
  | { type: "user_left"; room_id: string; uid: string }
  | { type: string; [key: string]: any };

interface PresenceContextValue {
  wsReady: boolean;
  onlineUsers: Record<string, Set<string>>;
  subscribePresence: (room_id: string) => void; // ダッシュボード用
  unsubscribePresence: (room_id: string) => void;
  enterRoom: (room_id: string) => void; // ルーム画面用
  leaveRoom: (room_id: string) => void;
  onEvent: (listener: (ev: Event) => void) => () => void;
}

const PresenceContext = createContext<PresenceContextValue | null>(null);

export const PresenceProvider = ({ children }: PropsWithChildren) => {
  const wsRef = useRef<WebSocket | null>(null);

  const [token, setToken] = useState<string | null>(null);
  const [wsReady, setWsReady] = useState(false);
  const [onlineUsers, setOnlineUsers] = useState<Record<string, Set<string>>>(
    {},
  );

  const subscribedRooms = useRef<Set<string>>(new Set()); // 「見るだけ」
  const enteredRooms = useRef<Set<string>>(new Set()); // 「実際に入室中」 ★追加

  const listeners = useRef<Set<(ev: Event) => void>>(new Set());

  /* ----------------------------- auth token ----------------------------- */
  useEffect(() => {
    supabase.auth.getSession().then(({ data }) => {
      setToken(data.session?.access_token ?? null);
    });
  }, []);

  /* ----------------------------- WebSocket ------------------------------ */
  useEffect(() => {
    if (!token) return;
    const ws = new WebSocket(
      `${process.env.NEXT_PUBLIC_WS_URL || "ws://localhost:8000/ws"}?token=${token}`,
    );
    wsRef.current = ws;

    ws.onopen = () => {
      setWsReady(true);
      // 再接続時は「本当に入室している部屋」だけを再送信 ★修正
      enteredRooms.current.forEach((room_id) =>
        ws.send(JSON.stringify({ type: "enter_room", room_id })),
      );
    };

    ws.onmessage = (e) => {
      let ev: Event;
      try {
        ev = JSON.parse(e.data);
      } catch {
        return;
      }

      /* -------- presence セットの更新 -------- */
      if (ev.type === "user_entered") {
        setOnlineUsers((prev) => {
          const next = { ...prev };
          (next[ev.room_id] ??= new Set()).add(ev.uid);
          return next;
        });
      } else if (ev.type === "user_left") {
        setOnlineUsers((prev) => {
          const next = { ...prev };
          next[ev.room_id]?.delete(ev.uid);
          return next;
        });
      }

      /* -------- 登録済みリスナーへ配信 -------- */
      listeners.current.forEach((fn) => fn(ev));
    };

    ws.onclose = () => {
      setWsReady(false);
      setTimeout(() => setToken(token), 3000); // 3秒後に再接続
    };

    return () => ws.close();
  }, [token]);

  /* --------------------------- ダッシュボード --------------------------- */
  const subscribePresence = useCallback(
    (room_id: string) => {
      if (subscribedRooms.current.has(room_id)) return;
      subscribedRooms.current.add(room_id); // ★追加
      api.getPresence(token!, room_id).then((list) => {
        setOnlineUsers((prev) => ({ ...prev, [room_id]: new Set(list) }));
      });
    },
    [token],
  );

  const unsubscribePresence = useCallback((room_id: string) => {
    subscribedRooms.current.delete(room_id);
    setOnlineUsers((prev) => {
      const next = { ...prev };
      delete next[room_id];
      return next;
    });
  }, []);

  /* ---------------------------- ルーム画面 ----------------------------- */
  const enterRoom = useCallback(
    (room_id: string) => {
      if (enteredRooms.current.has(room_id)) return; // 2重送信防止 ★追加
      if (wsRef.current?.readyState === WebSocket.OPEN) {
        wsRef.current.send(JSON.stringify({ type: "enter_room", room_id }));
      }
      enteredRooms.current.add(room_id); // ★追加
      // 最新 presence 取得
      api.getPresence(token!, room_id).then((list) => {
        setOnlineUsers((prev) => ({ ...prev, [room_id]: new Set(list) }));
      });
    },
    [token],
  );

  const leaveRoom = useCallback((room_id: string) => {
    if (enteredRooms.current.has(room_id)) {
      if (wsRef.current?.readyState === WebSocket.OPEN) {
        wsRef.current.send(JSON.stringify({ type: "leave_room", room_id }));
      }
      enteredRooms.current.delete(room_id); // ★追加
    }
    setOnlineUsers((prev) => {
      const next = { ...prev };
      delete next[room_id];
      return next;
    });
  }, []);

  /* ------------------------------ API ------------------------------- */
  const onEvent = useCallback((listener: (ev: Event) => void) => {
    listeners.current.add(listener);
    return () => listeners.current.delete(listener);
  }, []);

  return (
    <PresenceContext.Provider
      value={{
        wsReady,
        onlineUsers,
        subscribePresence,
        unsubscribePresence,
        enterRoom,
        leaveRoom,
        onEvent,
      }}
    >
      {children}
    </PresenceContext.Provider>
  );
};

export const usePresence = (): PresenceContextValue => {
  const ctx = useContext(PresenceContext);
  if (!ctx) throw new Error("usePresence must be used within PresenceProvider");
  return ctx;
};


--- FILE: ./lib/api.ts ---

// src/lib/api.ts
const API_BASE =
  process.env.NEXT_PUBLIC_API_BASE || "http://localhost:8000/api";

type ApiOptions = {
  method?: string;
  body?: any;
  token?: string;
  headers?: Record<string, string>;
};

async function api<T>(path: string, options: ApiOptions = {}): Promise<T> {
  let token = options.token;
  if (!token) throw new Error("JWT token required");
  const res = await fetch(`${API_BASE}${path}`, {
    method: options.method || "GET",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
      ...(options.headers || {}),
    },
    body: options.body ? JSON.stringify(options.body) : undefined,
  });
  if (!res.ok) {
    const err = await res.json().catch(() => ({}));
    throw new Error(err.detail || res.statusText);
  }
  return await res.json();
}

// --- ユーザー ---
export const getMe = (token: string) => api("/users/me", { token });
export const updateMe = (token: string, display_name: string) =>
  api("/users/me", { method: "PUT", token, body: { display_name } });
export const getUserPointHistory = (token: string) =>
  api("/users/me/points/history", { token });
export const getUserSettleHistory = (token: string) =>
  api("/users/me/settle/history", { token });

export async function createUser(
  token: string,
  { display_name, email, icon_url },
) {
  return api("/users", {
    method: "POST",
    token,
    body: { display_name, email, icon_url },
  });
}
// --- ルーム ---
export const createRoom = (
  token: string,
  room: { name: string; description?: string; color_id: number },
) => api("/rooms", { method: "POST", token, body: room });
export const listRooms = (token: string) => api("/rooms", { token });

// --- Presence ---
export const getPresence = (token: string, room_id: string) =>
  api<string[]>(`/rooms/${room_id}/presence`, { token });
export const getAllRooms = (token: string) => api("/rooms/all", { token });
export const getRoom = (token: string, room_id: string) =>
  api(`/rooms/${room_id}`, { token });
export const updateRoom = (
  token: string,
  room_id: string,
  updates: Partial<{ name: string; description: string; color_id: number }>,
) => api(`/rooms/${room_id}`, { method: "PUT", token, body: updates });
export const deleteRoom = (token: string, room_id: string) =>
  api(`/rooms/${room_id}`, { method: "DELETE", token });
export const joinRoom = (token: string, room_id: string) =>
  api(`/rooms/${room_id}/join`, { method: "POST", token });
export const cancelJoinRequest = (token: string, room_id: string) =>
  api(`/rooms/${room_id}/cancel_join`, { method: "POST", token });
export const leaveRoom = (token: string, room_id: string) =>
  api(`/rooms/${room_id}/leave`, { method: "POST", token });
export const approveMember = (
  token: string,
  room_id: string,
  applicant_user_id: string,
) =>
  api(`/rooms/${room_id}/approve`, {
    method: "POST",
    token,
    body: { applicant_user_id },
  });
export const rejectMember = (
  token: string,
  room_id: string,
  applicant_user_id: string,
) =>
  api(`/rooms/${room_id}/reject`, {
    method: "POST",
    token,
    body: { applicant_user_id },
  });

// --- ポイント ---
export const addPoints = (
  token: string,
  room_id: string,
  points: Array<{ uid: string; value: number }>,
  approved_by: string[],
) =>
  api(`/rooms/${room_id}/points`, {
    method: "POST",
    token,
    body: { points, approved_by },
  });
export const getPointHistory = (token: string, room_id: string) =>
  api(`/rooms/${room_id}/points/history`, { token });
export const approvePoint = (
  token: string,
  room_id: string,
  round_id: string,
) =>
  api(`/rooms/${room_id}/points/${round_id}/approve`, {
    method: "POST",
    token,
  });
export const getPointStatus = (
  token: string,
  room_id: string,
  round_id: string,
) => api(`/rooms/${room_id}/points/${round_id}/status`, { token });
export const deletePointRecord = (
  token: string,
  room_id: string,
  round_id: string,
) => api(`/rooms/${room_id}/points/${round_id}`, { method: "DELETE", token });

export const startPointRound = (token: string, room_id: string) =>
  api(`/rooms/${room_id}/points/start`, { method: "POST", token });

export const submitPoint = (
  token: string,
  room_id: string,
  uid: string,
  value: number,
) =>
  api(`/rooms/${room_id}/points/submit`, {
    method: "POST",
    token,
    body: { uid, value },
  });

export const finalizePointRound = (token: string, room_id: string) =>
  api(`/rooms/${room_id}/points/finalize`, { method: "POST", token });
// --- 精算 ---
export const settle = (
  token: string,
  room_id: string,
  to_uid: string,
  amount: number,
) =>
  api(`/rooms/${room_id}/settle`, {
    method: "POST",
    token,
    body: { to_uid, amount },
  });
export const approveSettlement = (
  token: string,
  room_id: string,
  settlement_id: string,
) =>
  api(`/rooms/${room_id}/settle/${settlement_id}/approve`, {
    method: "POST",
    token,
  });
export const getSettlementHistory = (token: string, room_id: string) =>
  api(`/rooms/${room_id}/settle/history`, { token });


--- FILE: ./lib/supabaseClient.ts ---

// lib/supabaseClient.ts
import { createClient } from '@supabase/supabase-js'

export const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
)



