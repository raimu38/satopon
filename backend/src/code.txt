--- FILE: ./__init__.py ---



--- FILE: ./api/__init__.py ---



--- FILE: ./api/misc.py ---

from fastapi import APIRouter, Depends, HTTPException
from src.schemas import SettlementCreate, PointRegisterRequest, PointInput
from src.utils import get_current_uid
from src.db import get_db, get_redis
from src.repositories.misc_repo import (
    PointRecordRepository,
    SettlementRepository,
    SettlementCacheRepository,
)
from src.repositories.room_repo import RoomRepository
from src.repositories.round_cache_repo import RoundCacheRepository
from src.services.misc_service import PointService, SettlementService
from src.ws import send_event, broadcast_event_to_room
from datetime import datetime
from functools import lru_cache
router = APIRouter()


@lru_cache()
def get_point_service():
    mongo = get_db()
    cache = get_redis()
    return PointService(
        PointRecordRepository(mongo),
        RoomRepository(mongo),
        RoundCacheRepository(cache),
    )

def get_settlement_service(db=Depends(get_db)):
    return SettlementService(SettlementRepository(db))

@router.post("/rooms/{room_id}/points")
async def add_points(
    room_id: str,
    data: PointRegisterRequest,
    current_uid: str = Depends(get_current_uid),
    service: PointService = Depends(get_point_service),
):
    await service.add_points(room_id, data.points, data.approved_by)
    return {"ok": True}

@router.get("/rooms/{room_id}/points/history")
async def point_history(room_id: str, service: PointService = Depends(get_point_service)):
    return await service.history(room_id)

@router.delete("/rooms/{room_id}/points/{round_id}")
async def delete_point_record(
    room_id: str,
    round_id: str,
    current_uid: str = Depends(get_current_uid),
    service: PointService = Depends(get_point_service),
):
    await service.logical_delete(room_id, round_id, current_uid)
    return {"ok": True}

@router.post("/rooms/{room_id}/settle")
async def settle(
    room_id: str,
    data: SettlementCreate,
    current_uid: str = Depends(get_current_uid),
    service: SettlementService = Depends(get_settlement_service),
):
    await service.create({
        "room_id": room_id,
        "from_uid": current_uid,
        "to_uid": data.to_uid,
        "amount": data.amount,
    })
    return {"ok": True}

@router.post("/rooms/{room_id}/settle/{settlement_id}/approve")
async def approve_settlement(
    room_id: str,
    settlement_id: str,
    current_uid: str = Depends(get_current_uid),
    service: SettlementService = Depends(get_settlement_service),
):
    await service.approve(settlement_id)
    return {"ok": True}

@router.get("/rooms/{room_id}/settle/history")
async def settlement_history(room_id: str, service: SettlementService = Depends(get_settlement_service)):
    return await service.history(room_id)

@router.post("/rooms/{room_id}/points/{round_id}/approve")
async def approve_point_record(
    room_id: str,
    round_id: str,
    current_uid: str = Depends(get_current_uid),
    service: PointService = Depends(get_point_service),
):
    await service.approve(room_id, round_id, current_uid)
    return {"ok": True}

@router.get("/rooms/{room_id}/points/{round_id}/status")
async def point_approval_status(
    room_id: str,
    round_id: str,
    service: PointService = Depends(get_point_service),
):
    return await service.get_approval_status(room_id, round_id)

# ユーザーごとの全ポイント記録
@router.get("/users/me/points/history")
async def user_point_history(
    current_uid: str = Depends(get_current_uid),
    service: PointService = Depends(get_point_service)
):
    return await service.history_by_uid(current_uid)

# ユーザーごとの全精算記録
@router.get("/users/me/settle/history")
async def user_settle_history(
    current_uid: str = Depends(get_current_uid),
    service: SettlementService = Depends(get_settlement_service)
):
    return await service.history_by_uid(current_uid)

# ——— 以下を追加 ———

@router.post("/rooms/{room_id}/points/start")
async def start_point_round(
    room_id: str,
    current_uid: str = Depends(get_current_uid),
    service: PointService = Depends(get_point_service),
):
    await service.start_round(room_id)
    return {"ok": True}

@router.post("/rooms/{room_id}/points/submit")
async def submit_point(
    room_id: str,
    data: PointInput,        # {uid, value}
    current_uid: str = Depends(get_current_uid),
    service: PointService = Depends(get_point_service),
):
    await service.submit_score(room_id, current_uid, data.value)
    return {"ok": True}

@router.post("/rooms/{room_id}/points/finalize")
async def finalize_point_round(
    room_id: str,
    current_uid: str = Depends(get_current_uid),
    service: PointService = Depends(get_point_service),
):
    return await service.finalize_round(room_id)

@router.post("/rooms/{room_id}/points/cancel")
async def cancel_point_round(
    room_id: str,
    reason: str,
    service: PointService = Depends(get_point_service),
):
    await service.cancel_round(room_id, reason)
    return {"ok": True}


# --- ① 精算リクエストをキャッシュに保存し、相手に通知 ---
@router.post("/rooms/{room_id}/settle/request")
async def request_settlement(
    room_id: str,
    data: SettlementCreate,
    current_uid: str = Depends(get_current_uid),
    redis_client=Depends(get_redis),
):
    cache = SettlementCacheRepository(redis_client)

    # 既に保留中か？
    exists = await cache.get_request(room_id, current_uid, data.to_uid)
    if exists:
        raise HTTPException(400, detail="既にリクエスト中です")

    # 自分の残高バリデーションはフロント or 別エンドポイントで行えます
    # とりあえずキャッシュ登録
    await cache.cache_request(room_id, current_uid, data.to_uid, data.amount)

    # WebSocket で相手に届く通知
    await send_event(data.to_uid, {
        "type": "settle_requested",
        "room_id": room_id,
        "from_uid": current_uid,
        "to_uid": data.to_uid,
        "amount": data.amount,
    })
    return {"ok": True}

# --- ② 承認: キャッシュ→永続化→通知 ---
@router.post("/rooms/{room_id}/settle/request/{from_uid}/approve")
async def approve_settlement(
    room_id: str,
    from_uid: str,
    current_uid: str = Depends(get_current_uid),
    redis_client=Depends(get_redis),
    point_svc: PointService = Depends(get_point_service),
    persist_svc: SettlementService = Depends(get_settlement_service),
):
    cache = SettlementCacheRepository(redis_client)

    # キャッシュからリクエスト取得
    req = await cache.get_request(room_id, from_uid, current_uid)
    if not req:
        raise HTTPException(404, detail="リクエストが見つからないか期限切れです")

    amount = req["amount"]

    # (A) 送信元(from_uid)の残高チェック
    hist_from = await point_svc.history_by_uid(from_uid)
    bal_from = sum(
        p["value"]
        for rec in hist_from
        for p in rec["points"]
        if p["uid"] == from_uid
    )
    if bal_from + amount > 0:
        raise HTTPException(400, detail="送信元の残高不足です")
    
    # (B) 受信側(current_uid)の残高制限チェック
    hist_to = await point_svc.history_by_uid(current_uid)
    bal_to = sum(
        p["value"]
        for rec in hist_to
        for p in rec["points"]
        if p["uid"] == current_uid
    )
    if bal_to - amount < 0:
        raise HTTPException(400, detail="受信側の残高制限を超えます")

    # 永続化: MongoDB に２つのポイントエントリを作成
    round_id = f"SETTLE_{from_uid}_{current_uid}_{int(datetime.utcnow().timestamp())}"
    await point_svc.point_repo.create({
        "room_id": room_id,
        "round_id": round_id,
        "points": [
            {"uid": from_uid,   "value": amount},
            {"uid": current_uid, "value": -amount},
        ],
        "approved_by": [from_uid, current_uid],
        "created_at": datetime.utcnow(),
        "is_deleted": False,
    })

    # キャッシュ削除
    await cache.clear_request(room_id, from_uid, current_uid)

    # ルーム全員へ完了通知
    await broadcast_event_to_room(room_id, {
        "type": "settle_completed",
        "room_id": room_id,
        "from_uid": from_uid,
        "to_uid": current_uid,
        "amount": amount,
    })
    return {"ok": True}

# --- ③ 拒否: キャッシュ削除＋通知 ---
@router.post("/rooms/{room_id}/settle/request/{from_uid}/reject")
async def reject_settlement(
    room_id: str,
    from_uid: str,
    current_uid: str = Depends(get_current_uid),
    redis_client=Depends(get_redis),
):
    cache = SettlementCacheRepository(redis_client)
    # キャッシュを消すだけ
    await cache.clear_request(room_id, from_uid, current_uid)
    # 送信元へ拒否通知
    await send_event(from_uid, {
        "type": "settle_rejected",
        "room_id": room_id,
        "by_uid": current_uid,
    })
    return {"ok": True}


--- FILE: ./api/room.py ---

from fastapi import APIRouter, Depends, HTTPException
from src.services.room_service import RoomService
from src.repositories.room_repo import RoomRepository
from src.repositories.misc_repo import PointRecordRepository
from src.db import get_db ,get_redis
from src.schemas import RoomCreate, RoomResponse, RoomUpdate, ApproveRejectBody
from typing import List
from src.utils import get_current_uid

router = APIRouter()

def get_room_service(db=Depends(get_db)):
    return RoomService(RoomRepository(db), PointRecordRepository(db))

@router.post("/rooms", response_model=dict)
async def create_room(
    data: RoomCreate,
    current_uid: str = Depends(get_current_uid),
    service: RoomService = Depends(get_room_service),
):
    room_id = await service.create_room(current_uid, data.dict())
    return {"room_id": room_id}

@router.get("/rooms", response_model=List[RoomResponse])
async def list_rooms(
    current_uid: str = Depends(get_current_uid),
    service: RoomService = Depends(get_room_service),
):
    return await service.list_user_rooms(current_uid)

@router.get("/rooms/{room_id}/presence", response_model=List[str])
async def get_presence(
    room_id: str,
    current_uid: str = Depends(get_current_uid),
    redis=Depends(get_redis),
):
    key = f"presence:{room_id}"
    members = await redis.smembers(key)
    # 文字列の set を配列にして返却
    return list(members)

@router.get("/rooms/all", response_model=List[RoomResponse])
async def list_all_rooms(
    service: RoomService = Depends(get_room_service)
):
    # すべてのis_archived=Falseなルームを返す
    return await service.list_all_rooms()
@router.get("/rooms/{room_id}", response_model=RoomResponse)
async def get_room(room_id: str, service: RoomService = Depends(get_room_service)):
    return await service.get_room(room_id)

@router.put("/rooms/{room_id}")
async def update_room(
    room_id: str,
    updates: RoomUpdate,
    current_uid: str = Depends(get_current_uid),
    service: RoomService = Depends(get_room_service),
):
    await service.update_room(room_id, updates.dict(exclude_unset=True), current_uid)
    return {"ok": True}

@router.delete("/rooms/{room_id}")
async def delete_room(
    room_id: str,
    current_uid: str = Depends(get_current_uid),
    service: RoomService = Depends(get_room_service),
):
    await service.delete_room(room_id, current_uid)
    return {"ok": True}

@router.post("/rooms/{room_id}/join")
async def join_room(
    room_id: str,
    current_uid: str = Depends(get_current_uid),
    service: RoomService = Depends(get_room_service)
):
    await service.request_join(room_id, current_uid)
    return {"ok": True}

@router.post("/rooms/{room_id}/cancel_join")
async def cancel_join_request(
        room_id:str,
        current_uid: str = Depends(get_current_uid),
        services: RoomService = Depends(get_room_service),
):
    await services.cancel_join_request(room_id, current_uid)
    return {"ok": True}


@router.post("/rooms/{room_id}/approve")
async def approve_member(
    room_id: str,
    body: ApproveRejectBody,
    current_uid: str = Depends(get_current_uid),
    service: RoomService = Depends(get_room_service)
):
    await service.approve_member(room_id, body.applicant_user_id, current_uid)
    return {"ok": True}

@router.post("/rooms/{room_id}/reject")
async def reject_member(
    room_id: str,
    body: ApproveRejectBody,
    current_uid: str = Depends(get_current_uid),
    service: RoomService = Depends(get_room_service)
):
    await service.reject_member(room_id, body.applicant_user_id, current_uid)
    return {"ok": True}

@router.post("/rooms/{room_id}/leave")
async def leave_room(
    room_id: str,
    current_uid: str = Depends(get_current_uid),
    service: RoomService = Depends(get_room_service)
):
    await service.leave_room(room_id, current_uid)
    return {"ok": True}



--- FILE: ./api/user.py ---

from fastapi import APIRouter, Depends, HTTPException
from src.services.user_service import UserService
from src.repositories.user_repo import UserRepository
from src.repositories.room_repo import RoomRepository
from src.db import get_db
from src.schemas import UserCreate, UserUpdate, UserResponse
from typing import List
from src.utils import get_current_uid, get_current_external_id
from src.ws import active_connections

router = APIRouter()



def get_user_service(db=Depends(get_db)):
    return UserService(UserRepository(db), RoomRepository(db))

@router.get("/users", response_model=List[UserResponse])
async def list_users(
    with_online: int = 0,
    service: UserService = Depends(get_user_service)
):
    users = await service.list_users()
    if with_online:
        # uidで比較し、is_onlineを動的付与
        for u in users:
            u["is_online"] = u["uid"] in active_connections
    return users

@router.post("/users", response_model=UserResponse)
async def create_user(
    user: UserCreate,
    external_id: str = Depends(get_current_external_id),
    service: UserService = Depends(get_user_service)
):
    return await service.create_user(user.dict(), external_id)

@router.get("/users/me", response_model=UserResponse)
async def get_me(
    current_uid: str = Depends(get_current_uid),   # ← ここ
    service: UserService = Depends(get_user_service)
):
    return await service.get_user(current_uid)

@router.put("/users/me", response_model=dict)
async def update_me(
    data: UserUpdate,
    current_uid: str = Depends(get_current_uid),   # ← ここ
    service: UserService = Depends(get_user_service)
):
    await service.update_display_name(current_uid, data.display_name)
    return {"ok": True}


@router.delete("/users/me", response_model=dict)
async def delete_me(
    current_uid: str = Depends(get_current_uid),
    service: UserService = Depends(get_user_service)
):
    await service.delete_user(current_uid)
    return {"ok": True}


--- FILE: ./config.py ---

import os

from dotenv import load_dotenv
load_dotenv()  # .envファイルを自動で読み込む

MONGODB_URI = os.getenv("MONGODB_URI", "mongodb://satopon_mongo:27017")
REDIS_URI = os.getenv("REDIS_URI", "redis://satopon_redis:6379/0")
MONGO_DB_NAME = os.getenv("MONGO_DB_NAME", "satopon")
JWT_SECRET = os.getenv("JWT_SECRET", "satopon-secret")
ALLOWED_ORIGINS = os.getenv("ALLOWED_ORIGINS", "*")

# 認証プロバイダ種別（supabase or firebase）
AUTH_PROVIDER = os.getenv("AUTH_PROVIDER", "supabase")

# 各プロバイダ個別の秘密鍵や設定も追加
SUPABASE_JWT_SECRET = os.getenv("SUPABASE_JWT_SECRET", None)
FIREBASE_PROJECT_ID = os.getenv("FIREBASE_PROJECT_ID", None)

# 例: どちらも存在しない場合はエラー出すなど、ここで制御できる
if AUTH_PROVIDER == "supabase" and not SUPABASE_JWT_SECRET:
    raise RuntimeError("SUPABASE_JWT_SECRET is required for Supabase auth")
if AUTH_PROVIDER == "firebase" and not FIREBASE_PROJECT_ID:
    raise RuntimeError("FIREBASE_PROJECT_ID is required for Firebase auth")


--- FILE: ./db.py ---

# src/db.py

import os
from motor.motor_asyncio import AsyncIOMotorClient
import redis.asyncio as redis  # redis-py公式の非同期クライアント

from .config import MONGODB_URI, MONGO_DB_NAME, REDIS_URI

# MongoDB
_mongo_client = AsyncIOMotorClient(MONGODB_URI)
db = _mongo_client[MONGO_DB_NAME]

# Redis
redis_client = redis.from_url(REDIS_URI, decode_responses=True)

def get_db():
    return db

def get_redis():
    return redis_client


--- FILE: ./main.py ---

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from motor.motor_asyncio import AsyncIOMotorClient
from src.api import user, room, misc
from .config import MONGODB_URI, MONGO_DB_NAME
from src.db import get_db
import os
from src import ws


# FastAPI app設定など
app = FastAPI()

# CORS
app.add_middleware(
      CORSMiddleware,
      allow_origins=["http://localhost","http://localhost:3000"],
      allow_credentials=True,
      allow_methods=["*"],
      allow_headers=["*"],
)

app.include_router(user.router, prefix="/api", tags=["user"])
app.include_router(room.router, prefix="/api", tags=["room"])
app.include_router(misc.router, prefix="/api", tags=["misc"])
app.include_router(ws.router)

# WebSocketやイベントも後述



--- FILE: ./models.py ---

from pydantic import BaseModel, Field, EmailStr
from typing import List, Optional
from datetime import datetime

# --- User ---
class UserModel(BaseModel):
    uid: str                   # 内部主キー
    external_id: str           # sub（supabaseやfirebaseのsub）
    display_name: str
    email: EmailStr
    icon_url: Optional[str] = None
    registered_at: datetime
    is_deleted: bool = False

# --- Room ---
class MemberObj(BaseModel):
    uid: str
    joined_at: datetime

class PendingMemberObj(BaseModel):
    uid: str
    requested_at: datetime

class RoomModel(BaseModel):
    room_id: str
    name: str
    description: Optional[str] = None
    color_id: int
    created_by: str
    created_at: datetime
    is_archived: bool = False
    members: List[MemberObj] = []
    pending_members: List[PendingMemberObj] = [] 

# --- PointRecord ---
class PointObj(BaseModel):
    uid: str
    value: int

class PointRecordModel(BaseModel):
    room_id: str
    round_id: str
    points: List[PointObj]
    created_at: datetime
    approved_by: List[str]
    is_deleted: bool = False

# --- Settlement ---
class SettlementModel(BaseModel):
    room_id: str
    from_uid: str
    to_uid: str
    amount: int
    approved: bool
    created_at: datetime
    approved_at: Optional[datetime] = None
    is_deleted: bool = False



--- FILE: ./repositories/__init__.py ---



--- FILE: ./repositories/misc_repo.py ---

from motor.motor_asyncio import AsyncIOMotorDatabase
from typing import Optional, List
from datetime import datetime

class PointRecordRepository:
    def __init__(self, db: AsyncIOMotorDatabase):
        self.collection = db.point_records

    async def create(self, data: dict):
        data["created_at"] = datetime.utcnow()
        data["is_deleted"] = False
        await self.collection.insert_one(data)
        return data["round_id"]

# repositories/misc_repo.py

# src/repositories/misc_repo.py か settlement_repo.py あたり

# src/repositories/misc_repo.py か settlement_repo.py 内

    async def history(self, room_id: str) -> List[dict]:
        cursor = self.collection.find({"room_id": room_id, "is_deleted": False})
        items = await cursor.to_list(length=100)
        for item in items:
            # _id を文字列化して settlement_id に乗せ替え
            if "_id" in item:
                item["settlement_id"] = str(item["_id"])
                del item["_id"]
        return items
    
    async def logical_delete(self, room_id: str, round_id: str) -> bool:
        result = await self.collection.update_one(
            {"room_id": room_id, "round_id": round_id}, {"$set": {"is_deleted": True}}
        )
        return result.modified_count == 1

    async def find_one(self, room_id: str, round_id: str) -> Optional[dict]:
        return await self.collection.find_one({
            "room_id": room_id,
            "round_id": round_id,
            "is_deleted": False
        })

    async def add_approval(self, room_id: str, round_id: str, uid: str):
        result = await self.collection.update_one(
            {"room_id": room_id, "round_id": round_id},
            {"$addToSet": {"approved_by": uid}}
        )
        return result.modified_count == 1

    async def history_by_uid(self, uid: str) -> List[dict]:
        cursor = self.collection.find({"points.uid": uid, "is_deleted": False})
        return await cursor.to_list(length=100)

class SettlementRepository:
    def __init__(self, db: AsyncIOMotorDatabase):
        self.collection = db.settlements

    async def create(self, data: dict):
        data["created_at"] = datetime.utcnow()
        data["is_deleted"] = False
        data["approved"] = False
        await self.collection.insert_one(data)
        return str(data["_id"])

    async def approve(self, settlement_id: str):
        from bson import ObjectId
        result = await self.collection.update_one(
            {"_id": ObjectId(settlement_id), "is_deleted": False},
            {"$set": {"approved": True, "approved_at": datetime.utcnow()}}
        )
        return result.modified_count == 1

    async def history(self, room_id: str) -> List[dict]:
        cursor = self.collection.find({"room_id": room_id, "is_deleted": False})
        items = await cursor.to_list(length=100)
        for item in items:
            item["settlement_id"] = str(item["_id"])
            del item["_id"]
        return items

    async def history_by_uid(self, uid: str) -> List[dict]:
        cursor = self.collection.find(
            {"$or": [{"from_uid": uid}, {"to_uid": uid}], "is_deleted": False}
        )
        return await cursor.to_list(length=100)



# src/repositories/misc_repo.py

import redis.asyncio as redis

class SettlementCacheRepository:
    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client

    def _key(self, room_id: str, from_uid: str, to_uid: str) -> str:
        return f"settle:{room_id}:{from_uid}->{to_uid}"

    async def cache_request(self, room_id: str, from_uid: str, to_uid: str, amount: int):
        k = self._key(room_id, from_uid, to_uid)
        # Hash にして TTL 180 秒
        await self.redis.hset(k, mapping={
            "room_id": room_id,
            "from_uid": from_uid,
            "to_uid": to_uid,
            "amount": amount,
        })
        await self.redis.expire(k, 180)

    async def get_request(self, room_id: str, from_uid: str, to_uid: str):
        k = self._key(room_id, from_uid, to_uid)
        data = await self.redis.hgetall(k)
        if not data or "amount" not in data:
            return None
        return {
            "room_id": data["room_id"],
            "from_uid": data["from_uid"],
            "to_uid": data["to_uid"],
            "amount": int(data["amount"]),
        }

    async def clear_request(self, room_id: str, from_uid: str, to_uid: str):
        k = self._key(room_id, from_uid, to_uid)
        await self.redis.delete(k)


--- FILE: ./repositories/room_repo.py ---

from motor.motor_asyncio import AsyncIOMotorDatabase
from typing import Optional, List
from datetime import datetime

class RoomRepository:
    def __init__(self, db: AsyncIOMotorDatabase):
        self.collection = db.rooms

    async def exists(self, room_id: str) -> bool:
        doc = await self.collection.find_one({"room_id": room_id, "is_archived": False})
        return doc is not None

    async def create(self, data: dict) -> str:
        data["created_at"] = datetime.utcnow()
        data["is_archived"] = False
        await self.collection.insert_one(data)
        return data["room_id"]

    async def get_by_id(self, room_id: str) -> Optional[dict]:
        doc = await self.collection.find_one({"room_id": room_id, "is_archived": False})
        if doc is not None and "pending_members" not in doc:
            doc["pending_members"] = []
        return doc

    async def list_all(self) -> List[dict]:
        cursor = self.collection.find({"is_archived": False})
        return await cursor.to_list(length=1000)

    async def update(self, room_id: str, updates: dict) -> bool:
        result = await self.collection.update_one(
            {"room_id": room_id, "is_archived": False}, {"$set": updates}
        )
        return result.modified_count == 1

    async def list_rooms_for_user(self, uid: str) -> List[dict]:
        cursor = self.collection.find({"members.uid": uid, "is_archived": False})
        return await cursor.to_list(length=100)

    async def add_member(self, room_id: str, uid: str):
        await self.collection.update_one(
            {"room_id": room_id, "is_archived": False, "members.uid": {"$ne": uid}},
            {"$push": {"members": {"uid": uid, "joined_at": datetime.utcnow()}}}
        )
    async def add_pending_member(self, room_id: str, uid: str):
        await self.collection.update_one(
            {"room_id": room_id, "is_archived": False},
            {"$push": {"pending_members": {"uid": uid, "requested_at": datetime.utcnow()}}}
        )

    async def approve_pending_member(self, room_id: str, uid: str):
        await self.collection.update_one(
            {"room_id": room_id, "is_archived": False},
            {
                "$pull": {"pending_members": {"uid": uid}},
                "$push": {"members": {"uid": uid, "joined_at": datetime.utcnow()}}
            }
        )

    async def remove_pending_member(self, room_id: str, uid: str):
        await self.collection.update_one(
            {"room_id": room_id, "is_archived": False},
            {"$pull": {"pending_members": {"uid": uid}}}
        )

    async def remove_member(self, room_id: str, uid: str):
        await self.collection.update_one(
            {"room_id": room_id, "is_archived": False},
            {"$pull": {"members": {"uid": uid}}}
        )


--- FILE: ./repositories/round_cache_repo.py ---

# src/repositories/round_cache_repo.py

class RoundCacheRepository:
    def __init__(self, redis):
        self.redis = redis

    def _round_key(self, room_id: str) -> str:
        return f"round:{room_id}"

    def _subs_key(self, room_id: str) -> str:
        return f"{self._round_key(room_id)}:subs"

    def _approvals_key(self, room_id: str) -> str:
        return f"{self._round_key(room_id)}:apprs"

    async def start(self, room_id: str, round_id: str, ttl: int = 180) -> None:
        # ラウンド開始情報を保存し、TTLをセット
        await self.redis.hset(self._round_key(room_id), mapping={"round_id": round_id})
        await self.redis.expire(self._round_key(room_id), ttl)
        await self.redis.expire(self._subs_key(room_id), ttl)
        await self.redis.expire(self._approvals_key(room_id), ttl)

    async def get_round_id(self, room_id: str) -> str | None:
        # 現在のラウンドIDを取得
        return await self.redis.hget(self._round_key(room_id), "round_id")

    async def add_submission(self, room_id: str, uid: str, value: int, ttl: int = 180) -> str | None:
        # スコアを記録し、TTLをリフレッシュ
        await self.redis.hset(self._subs_key(room_id), uid, value)
        await self.redis.expire(self._subs_key(room_id), ttl)
        # ラウンドIDもTTLリフレッシュ
        await self.redis.expire(self._round_key(room_id), ttl)
        return await self.get_round_id(room_id)

    async def get_submissions(self, room_id: str) -> dict[str, int]:
        raw = await self.redis.hgetall(self._subs_key(room_id))
        return {k: int(v) for k, v in raw.items()}

    async def add_approval(self, room_id: str, uid: str, ttl: int = 180) -> None:
        await self.redis.sadd(self._approvals_key(room_id), uid)
        await self.redis.expire(self._approvals_key(room_id), ttl)
        await self.redis.expire(self._round_key(room_id), ttl)

    async def get_approvals(self, room_id: str) -> set[str]:
        return await self.redis.smembers(self._approvals_key(room_id))

    async def clear(self, room_id: str) -> None:
        # ラウンド関連キーをすべて削除
        await self.redis.delete(
            self._round_key(room_id),
            self._subs_key(room_id),
            self._approvals_key(room_id),
        )


--- FILE: ./repositories/user_repo.py ---

from src.models import UserModel
from motor.motor_asyncio import AsyncIOMotorDatabase
from typing import Optional, List
from datetime import datetime

class UserRepository:
    def __init__(self, db: AsyncIOMotorDatabase):
        self.collection = db.users

    async def get_by_uid(self, uid: str) -> Optional[dict]:
        return await self.collection.find_one({"uid": uid, "is_deleted": False})

    async def get_by_external_id(self, external_id: str) -> Optional[dict]:
        return await self.collection.find_one({"external_id": external_id, "is_deleted": False})

    async def create(self, data: dict) -> str:
        data["registered_at"] = datetime.utcnow()
        data["is_deleted"] = False
        await self.collection.insert_one(data)
        return data["uid"]

    async def update_display_name(self, uid: str, display_name: str) -> bool:
        result = await self.collection.update_one(
            {"uid": uid, "is_deleted": False},
            {"$set": {"display_name": display_name}}
        )
        return result.modified_count == 1

    async def list_all(self) -> List[dict]:
        cursor = self.collection.find({"is_deleted": False})
        return await cursor.to_list(length=1000)

    async def logical_delete(self, uid: str) -> bool:
        result = await self.collection.update_one(
            {"uid": uid, "is_deleted": False},
            {"$set": {"is_deleted": True}}
        )
        return result.modified_count == 1



--- FILE: ./schemas.py ---

# src/schemas.py

from pydantic import BaseModel, EmailStr
from typing import List, Optional
from datetime import datetime

# --- User ---
class UserCreate(BaseModel):
    display_name: str
    email: EmailStr
    icon_url: Optional[str] = None

class UserResponse(BaseModel):
    uid: str
    display_name: str
    email: EmailStr
    icon_url: Optional[str]
    registered_at: datetime
    is_online: Optional[bool] = None   # 追加

class UserUpdate(BaseModel):
    display_name: str

# --- Room ---
class RoomCreate(BaseModel):
    name: str
    description: Optional[str] = None
    color_id: int

class RoomUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    color_id: Optional[int] = None

class RoomResponse(BaseModel):
    room_id: str
    name: str
    description: Optional[str]
    color_id: int
    created_by: str
    created_at: datetime
    is_archived: bool
    members: List[dict]
    pending_members: List[dict]   # ←これを追加

class ApproveRejectBody(BaseModel):
    applicant_user_id: str

# --- Point ---
class PointInput(BaseModel):
    uid: str
    value: int

class PointRegisterRequest(BaseModel):
    points: List[PointInput]
    approved_by: List[str]

class PointHistoryResponse(BaseModel):
    round_id: str
    points: List[PointInput]
    created_at: datetime
    approved_by: List[str]
    is_deleted: bool
    _id: Optional[str]

# --- Settlement ---
class SettlementCreate(BaseModel):
    to_uid: str
    amount: int

class SettlementHistoryResponse(BaseModel):
    from_uid: str
    to_uid: str
    amount: int
    approved: bool
    created_at: datetime
    approved_at: Optional[datetime]
    is_deleted: bool


--- FILE: ./services/__init__.py ---



--- FILE: ./services/misc_service.py ---

# src/services/misc_service.py

from src.repositories.misc_repo import PointRecordRepository, SettlementRepository
from src.repositories.room_repo import RoomRepository
from fastapi import HTTPException
from src.ws import broadcast_event_to_room, send_event
from typing import Dict, List
from datetime import datetime
import asyncio
import random
import string

def _make_round_id(length: int = 6) -> str:
    chars = string.ascii_uppercase + string.digits
    return ''.join(random.choices(chars, k=length))

class PointService:
    def __init__(
        self,
        point_repo: PointRecordRepository,
        room_repo: RoomRepository,
        cache_repo  # RoundCacheRepository
    ):
        self.point_repo = point_repo
        self.room_repo = room_repo
        self.cache = cache_repo
        self._timeout_tasks: Dict[str, asyncio.Task] = {}

    async def add_points(self, room_id: str, round_id: str, points: List, approved_by: List[str]):
        room = await self.room_repo.get_by_id(room_id)
        if not room:
            raise HTTPException(status_code=404, detail="Room not found")
        members = {m["uid"] for m in room.get("members", [])}
        if members != set(approved_by):
            raise HTTPException(status_code=400, detail="All members must approve the record.")
        return await self.point_repo.create({
            "room_id": room_id,
            "round_id": round_id,
            "points": [p.dict() for p in points],
            "approved_by": approved_by,
            "created_at": datetime.utcnow(),
            "is_deleted": False,
        })

    async def history(self, room_id: str):
        return await self.point_repo.history(room_id)

    async def history_by_uid(self, uid: str):
        return await self.point_repo.history_by_uid(uid)

    async def logical_delete(self, room_id: str, round_id: str, current_uid: str):
        room = await self.room_repo.get_by_id(room_id)
        if not room:
            raise HTTPException(status_code=404, detail="Room not found")
        if room["created_by"] != current_uid:
            raise HTTPException(status_code=403, detail="Only room owner can delete point record")
        return await self.point_repo.logical_delete(room_id, round_id)

    async def start_round(self, room_id: str):
        room = await self.room_repo.get_by_id(room_id)
        if not room:
            raise HTTPException(status_code=404, detail="Room not found")
        # 既存ラウンドをクリア
        await self.cache.clear(room_id)
        # 新ラウンド ID 発行・保存
        round_id = _make_round_id()
        await self.cache.start(room_id, round_id)
        # タイムアウト監視タスク
        if room_id in self._timeout_tasks:
            self._timeout_tasks[room_id].cancel()
        self._timeout_tasks[room_id] = asyncio.create_task(self._watch_timeout(room_id))
        # 開始通知
        await broadcast_event_to_room(room_id, {
            "type": "point_round_started",
            "room_id": room_id,
            "round_id": round_id,
        })

    async def _watch_timeout(self, room_id: str):
        try:
            await asyncio.sleep(180)
            await self.cancel_round(room_id, reason="Timeout after 3 minutes")
        except asyncio.CancelledError:
            pass
        finally:
            self._timeout_tasks.pop(room_id, None)

    async def submit_score(self, room_id: str, uid: str, value: int):
        # Redis にスコアを一時保存
        round_id = await self.cache.add_submission(room_id, uid, value)
        if not round_id:
            raise HTTPException(status_code=400, detail="No active round")

        # 提出通知
        await broadcast_event_to_room(room_id, {
            "type": "point_submitted",
            "room_id": room_id,
            "round_id": round_id,
            "uid": uid,
        })

        # 全員提出時の最終表通知
        room = await self.room_repo.get_by_id(room_id)
        subs = await self.cache.get_submissions(room_id)
        if len(subs) == len(room.get("members", [])):
            # タイマー取消
            if task := self._timeout_tasks.pop(room_id, None):
                task.cancel()
            total = sum(subs.values())
            if total != 0:
                # 合計がゼロでないならキャンセル
                await broadcast_event_to_room(room_id, {
                    "type": "point_round_cancelled",
                    "room_id": room_id,
                    "round_id": round_id,
                    "reason": "Sum is not zero",
                })
                await self.cache.clear(room_id)
            else:
                # 合計ゼロなら最終表のみ通知（DB登録は承認後にまとめて）
                await broadcast_event_to_room(room_id, {
                    "type": "point_final_table",
                    "room_id": room_id,
                    "round_id": round_id,
                    "table": subs,
                })

    async def finalize_round(self, room_id: str):
        # 合計チェックと最終表通知のみ
        subs = await self.cache.get_submissions(room_id)
        if not subs:
            raise HTTPException(status_code=400, detail="No active round")
        total = sum(subs.values())
        round_id = await self.cache.get_round_id(room_id)
        if total != 0:
            await self.cancel_round(room_id, reason="Sum is not zero")
            raise HTTPException(status_code=400, detail="Sum is not zero")

        await broadcast_event_to_room(room_id, {
            "type": "point_final_table",
            "room_id": room_id,
            "round_id": round_id,
            "table": subs,
        })
        return {"round_id": round_id, "table": subs}

    async def approve(self, room_id: str, round_id: str, current_uid: str):
        # Redis の approvals セットに追加
        await self.cache.add_approval(room_id, current_uid)

        # 全承認状況を取得
        approvals = await self.cache.get_approvals(room_id)
        approvals = set(approvals)
        room = await self.room_repo.get_by_id(room_id)
        members = {m["uid"] for m in room.get("members", [])}

        # 各自の承認通知
        await broadcast_event_to_room(room_id, {
            "type": "point_approved",
            "room_id": room_id,
            "round_id": round_id,
            "uid": current_uid,
        })

        # 全員承認が揃ったらまとめて永続化
        if approvals | {current_uid} == members:
            subs = await self.cache.get_submissions(room_id)
            # MongoDB に一度だけ書き込む
            await self.point_repo.create({
                "room_id": room_id,
                "round_id": round_id,
                "points": [{"uid": k, "value": v} for k, v in subs.items()],
                "approved_by": list(members),
                "created_at": datetime.utcnow(),
                "is_deleted": False,
            })
            # キャッシュクリア
            await self.cache.clear(room_id)
            # 完全承認完了通知
            await broadcast_event_to_room(room_id, {
                "type": "point_fully_approved",
                "room_id": room_id,
                "round_id": round_id,
                "approved_by": list(members),
            })

    async def get_approval_status(self, room_id: str, round_id: str):
        # Redis に残っていればそれ、なければ最終的に DB を参照
        approvals = await self.cache.get_approvals(room_id)
        if approvals:
            return {"approved_by": list(approvals)}
        # キャッシュに何もなければ既存レコードから
        record = await self.point_repo.find_one(room_id, round_id)
        if not record:
            raise HTTPException(status_code=404, detail="Record not found")
        return {"approved_by": record.get("approved_by", [])}

    async def cancel_round(self, room_id: str, reason: str):
        round_id = await self.cache.get_round_id(room_id)
        if task := self._timeout_tasks.pop(room_id, None):
            task.cancel()
        await broadcast_event_to_room(room_id, {
            "type": "point_round_cancelled",
            "room_id": room_id,
            "round_id": round_id,
            "reason": reason,
        })
        await self.cache.clear(room_id)


class SettlementService:
    def __init__(self, repo: SettlementRepository):
        self.repo = repo

    async def create(self, data: dict):
        return await self.repo.create(data)

    async def approve(self, settlement_id: str):
        return await self.repo.approve(settlement_id)

    async def history(self, room_id: str):
        return await self.repo.history(room_id)

    async def history_by_uid(self, uid: str):
        return await self.repo.history_by_uid(uid)


    async def validate_request(self, room_id: str, from_uid: str, to_uid: str, amount: int):
        # (1) 同じルームに属しているか
        room = await self.room_repo.get_by_id(room_id)
        members = {m["uid"] for m in room.get("members", [])}
        if from_uid not in members or to_uid not in members:
            raise HTTPException(400, "相手が同じルームにいません")
        # (2) 送信元残高チェック
        hist = await self.point_repo.history_by_uid(from_uid)
        bal = sum(p.value for rec in hist for p in rec.points if p.uid == from_uid)
        if bal + amount > 0:
            raise HTTPException(400, "あなたの残高不足です")
        # (3) 受信側残高チェック
        hist2 = await self.point_repo.history_by_uid(to_uid)
        bal2 = sum(p.value for rec in hist2 for p in rec.points if p.uid == to_uid)
        if bal2 - amount < 0:
            raise HTTPException(400, "相手の残高制限を超えます")


--- FILE: ./services/room_service.py ---

from src.repositories.room_repo import RoomRepository
from src.repositories.misc_repo import PointRecordRepository
from fastapi import HTTPException
from datetime import datetime
import uuid
from src.ws import send_event
import random
import string
import asyncio

def generate_room_id(length=5):
    chars = string.ascii_uppercase + string.digits  # 例：A-Z, 0-9
    return ''.join(random.choices(chars, k=length))



class RoomService:
    def __init__(self, room_repo: RoomRepository, point_repo: PointRecordRepository):
        self.room_repo = room_repo
        self.point_repo = point_repo
        self.pending_timers = {}

    async def create_room(self, uid: str, data: dict):
        while True:
            room_id = generate_room_id(5)
            if not await self.room_repo.exists(room_id):
                break

        payload = {
            "room_id": room_id,
            "name": data["name"],
            "description": data.get("description"),
            "color_id": data["color_id"],
            "created_by": uid,
            "created_at": datetime.utcnow(),
            "is_archived": False,
            "members": [{"uid": uid, "joined_at": datetime.utcnow()}],
            "pending_members": []
        }
        await self.room_repo.create(payload)
        return room_id

    async def get_room(self, room_id: str):
        room = await self.room_repo.get_by_id(room_id)
        if not room:
            raise HTTPException(status_code=404, detail="Room not found")
        return room
    async def list_all_rooms(self):
        return await self.room_repo.list_all()

    async def list_user_rooms(self, uid: str):
        return await self.room_repo.list_rooms_for_user(uid)

    async def update_room(self, room_id: str, updates: dict, current_uid: str):
        room = await self.room_repo.get_by_id(room_id)
        if not room:
            raise HTTPException(status_code=404, detail="Room not found")
        if room["created_by"] != current_uid:
            raise HTTPException(status_code=403, detail="Not allowed to update this room")
        return await self.room_repo.update(room_id, updates)

    async def delete_room(self, room_id: str, current_uid: str):
        room = await self.room_repo.get_by_id(room_id)
        if not room:
            raise HTTPException(status_code=404, detail="Room not found")
        if room["created_by"] != current_uid:
            raise HTTPException(status_code=403, detail="Not allowed to delete this room")

        # --- 全員ポイント残高チェック ---
        point_histories = await self.point_repo.history(room_id)
        balances = {}
        for record in point_histories:
            if record.get("is_deleted"):
                continue
            for pt in record.get("points", []):
                uid = pt["uid"]
                balances[uid] = balances.get(uid, 0) + pt["value"]
        for member in room.get("members", []):
            if balances.get(member["uid"], 0) != 0:
                raise HTTPException(status_code=400, detail="ルームメンバーにポイント残高があるため削除不可")
        # 論理削除
        return await self.room_repo.update(room_id, {"is_archived": True})

    async def join_room(self, room_id: str, uid: str):
        room = await self.room_repo.get_by_id(room_id)
        if not room:
            raise HTTPException(status_code=404, detail="Room not found")
        # すでにメンバーなら何もしない
        if any(m["uid"] == uid for m in room.get("members", [])):
            return True
        await self.room_repo.add_member(room_id, uid)
        return True

    async def request_join(self, room_id: str, applicant_uid: str):
        room = await self.room_repo.get_by_id(room_id)
        if any(m["uid"] == applicant_uid for m in room.get("members", [])):
            raise HTTPException(status_code=400, detail="Already a member")
        if any(m["uid"] == applicant_uid for m in room.get("pending_members", [])):
            raise HTTPException(status_code=400, detail="Already requested")
        await self.room_repo.add_pending_member(room_id, applicant_uid)
        for member in room["members"]:
            await send_event(member["uid"], {"type": "join_request", "room_id": room_id, "applicant_uid": applicant_uid})
        # タイマー管理...
    
            # タイマー管理
        key = f"{room_id}:{applicant_uid}"
        if key in self.pending_timers:
            self.pending_timers[key].cancel()
        self.pending_timers[key] = asyncio.create_task(
            self._auto_cancel_join_request(room_id, applicant_uid, key)
        )
    
    async def _auto_cancel_join_request(self, room_id, applicant_uid, key):
        try:
            await asyncio.sleep(30)
            # まだpendingなら自動キャンセル
            room = await self.room_repo.get_by_id(room_id)
            if any(m["uid"] == applicant_uid for m in room.get("pending_members", [])):
                await self.cancel_join_request(room_id, applicant_uid)
        except asyncio.CancelledError:
            pass
        finally:
            self.pending_timers.pop(key, None)

    def _cancel_pending_timer(self, room_id, applicant_uid):
        key = f"{room_id}:{applicant_uid}"
        task = self.pending_timers.pop(key, None)
        if task:
            task.cancel()

    async def approve_member(self, room_id: str, applicant_uid: str, approver_uid: str):
        room = await self.room_repo.get_by_id(room_id)
        if not any(m["uid"] == approver_uid for m in room["members"]):
            raise HTTPException(status_code=403, detail="No permission")
        await self.room_repo.approve_pending_member(room_id, applicant_uid)
        await send_event(applicant_uid, {"type": "join_approved", "room_id": room_id})
        self._cancel_pending_timer(room_id, applicant_uid)


    async def cancel_join_request(self, room_id: str, user_id: str):
        room = await self.room_repo.get_by_id(room_id)
        if not room:
            raise HTTPException(status_code=404, detail="Room not found")
        pending_members = room.get("pending_members", [])
        if not any(m["uid"] == user_id for m in pending_members):
            raise HTTPException(status_code=400, detail="Not in pending list")
        await self.room_repo.remove_pending_member(room_id, user_id)
        for m in room["members"]:
            await send_event(m["uid"], {"type": "join_request_cancelled", "room_id": room_id, "user_id": user_id})
        await send_event(user_id, {"type": "join_request_cancelled", "room_id": room_id, "user_id": user_id})
        self._cancel_pending_timer(room_id, user_id)

    async def reject_member(self, room_id: str, applicant_uid: str, approver_uid: str):
        room = await self.room_repo.get_by_id(room_id)
        # 承認者がメンバーでなければ拒否
        if not any(m["uid"] == approver_uid for m in room["members"]):
            raise HTTPException(status_code=403, detail="No permission")
        # pendingにいなければエラー
        if not any(m["uid"] == applicant_uid for m in room.get("pending_members", [])):
            raise HTTPException(status_code=400, detail="Not in pending list")
        # pending_membersから削除のみ
        # pending_members から削除
        await self.room_repo.remove_pending_member(room_id, applicant_uid)
        # 拒否されたことを申請者に通知 → クライアント側で pending_members リストから消える
        from src.ws import send_event
        await send_event(applicant_uid, {
            "type": "join_request_cancelled",
            "room_id": room_id,
            "user_id": applicant_uid
        })

    async def leave_room(self, room_id: str, uid: str):
        room = await self.room_repo.get_by_id(room_id)
        if not room:
            raise HTTPException(status_code=404, detail="Room not found")
        # 作成者自身の場合
        if room["created_by"] == uid:
            # 自分以外にメンバーがいるなら退会不可
            members = [m for m in room.get("members", []) if m["uid"] != uid]
            if members:
                raise HTTPException(status_code=400, detail="ルーム作成者は他のメンバーがいる間は退会できません")
            # 作成者1人だけなら→退会＝削除で良い（バリデーションはdelete_roomのロジックでOK）
            await self.delete_room(room_id, uid)
            return True
        # ポイント残高チェック
        balance = 0
        from collections import defaultdict
        point_histories = await self.point_repo.history(room_id)
        for record in point_histories:
            if record.get("is_deleted"): continue
            for pt in record.get("points", []):
                if pt["uid"] == uid:
                    balance += pt["value"]
        if balance != 0:
            raise HTTPException(status_code=400, detail="ポイント残高が0でないため退会不可")
        await self.room_repo.remove_member(room_id, uid)
        return True


--- FILE: ./services/user_service.py ---

import random
import string
from src.repositories.user_repo import UserRepository
from src.repositories.room_repo import RoomRepository
from fastapi import HTTPException

def generate_uid(length=8):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

class UserService:
    def __init__(self, repo: UserRepository, room_repo: RoomRepository):
        self.repo = repo
        self.room_repo = room_repo

    # JWTのsub or uid = external_id として渡される
    async def create_user(self, user_data: dict, external_id: str):
        user_data = user_data.copy()
        user_data["external_id"] = external_id

    # まずactiveなユーザーを探す
        exists = await self.repo.get_by_external_id(external_id)
        if exists:
            return exists

    # 論理削除ユーザーを復活させる
        deleted_user = await self.repo.collection.find_one({"external_id": external_id, "is_deleted": True})
        if deleted_user:
            await self.repo.collection.update_one(
                {"external_id": external_id},
                {"$set": {**user_data, "is_deleted": False}}
            )
            return await self.repo.get_by_external_id(external_id)

    # どちらもいなければ新規
        uid = generate_uid()
        while await self.repo.get_by_uid(uid):
            uid = generate_uid()
        user_data["uid"] = uid

        await self.repo.create(user_data)
        return await self.repo.get_by_uid(uid)

    # DB主キーuidで取得
    async def get_user(self, uid: str):
        user = await self.repo.get_by_uid(uid)
        if not user:
            raise Exception("User not found")
        return user


    async def update_display_name(self, uid: str, display_name: str):
        ok = await self.repo.update_display_name(uid, display_name)
        if not ok:
            raise HTTPException(status_code=404, detail="User not found or already deleted")
        return ok

    async def list_users(self):
        return await self.repo.list_all()

    async def delete_user(self, uid: str):
        # ルーム所属チェック
        rooms = await self.room_repo.list_rooms_for_user(uid)
        if rooms:
            raise Exception("ユーザーはまだいずれかのルームに所属しているため削除できません")
        # 論理削除
        ok = await self.repo.logical_delete(uid)
        if not ok:
            raise Exception("ユーザー削除に失敗しました")
        return True





--- FILE: ./utils.py ---

import logging
from fastapi import Request, HTTPException, status, Depends
from jose import jwt
from src.config import AUTH_PROVIDER, SUPABASE_JWT_SECRET, FIREBASE_PROJECT_ID
from src.db import get_db

logger = logging.getLogger(__name__)

async def get_current_uid(
    request: Request,
    db=Depends(get_db)
) -> str:
    auth = request.headers.get("Authorization")
    logger.debug(f"Authorization header: {auth}")
    if not auth or not auth.startswith("Bearer "):
        logger.warning("Authorization header missing or invalid")
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)
    token = auth.split()[1]
    try:
        # --- JWTからexternal_idを取得 ---
        if AUTH_PROVIDER == "supabase":
            try:
                payload = jwt.decode(token, SUPABASE_JWT_SECRET, algorithms=["HS256"], audience="authenticated")
            except Exception as e:
                logger.error("supabase decode error: %s", e)
                raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=f"supabase decode error: {e}")
            external_id = payload["sub"]

        elif AUTH_PROVIDER == "firebase":
            from google.auth.transport import requests
            from google.oauth2 import id_token
            id_info = id_token.verify_oauth2_token(token, requests.Request(), FIREBASE_PROJECT_ID)
            external_id = id_info["uid"]
        else:
            logger.error(f"Unknown AUTH_PROVIDER: {AUTH_PROVIDER}")
            raise HTTPException(status_code=500, detail="Invalid AUTH_PROVIDER setting")

        # --- DBからexternal_id→uidを逆引き ---
        user = await db.users.find_one({"external_id": external_id, "is_deleted": False})
        if not user:
            logger.warning(f"User with external_id={external_id} not found")
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="User not registered")
        return user["uid"]

    except Exception as e:
        logger.error(f"JWT decode/verify failed: {e}")
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=f"JWT verify failed: {type(e).__name__}: {e}")

async def get_current_external_id(request: Request) -> str:
    auth = request.headers.get("Authorization")
    if not auth or not auth.startswith("Bearer "):
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)
    token = auth.split()[1]
    # Supabase例
    payload = jwt.decode(token, SUPABASE_JWT_SECRET, algorithms=["HS256"], audience="authenticated")
    return payload["sub"]



--- FILE: ./ws.py ---

from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Query, status, HTTPException
from jose import jwt
from src.config import SUPABASE_JWT_SECRET, AUTH_PROVIDER, FIREBASE_PROJECT_ID
from src.db import db, redis_client
import asyncio

router = APIRouter()
active_connections = {}

# トークンから「アプリuid」抽出
async def get_uid_from_token(token: str):
    print(f"[WS] get_uid_from_token called. token={token[:16]}...")
    if not token:
        print("[WS] No token provided.")
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)
    # --- sub or uid 抜き出し ---
    if AUTH_PROVIDER == "supabase":
        try:
            payload = jwt.decode(token, SUPABASE_JWT_SECRET, algorithms=["HS256"], audience="authenticated")
            external_id = payload["sub"]
            print(f"[WS] Supabase JWT decode OK. sub={external_id}")
        except Exception as e:
            print(f"[WS] Supabase JWT decode ERROR: {e}")
            raise
    elif AUTH_PROVIDER == "firebase":
        try:
            from google.auth.transport import requests
            from google.oauth2 import id_token
            id_info = id_token.verify_oauth2_token(token, requests.Request(), FIREBASE_PROJECT_ID)
            external_id = id_info["uid"]
            print(f"[WS] Firebase JWT decode OK. uid={external_id}")
        except Exception as e:
            print(f"[WS] Firebase JWT decode ERROR: {e}")
            raise
    else:
        print("[WS] Invalid auth provider")
        raise HTTPException(status_code=400, detail="Invalid auth provider")

    # --- external_idからuidをDB検索 ---
    user = await db.users.find_one({"external_id": external_id, "is_deleted": False})
    if not user:
        print(f"[WS] User not found for external_id={external_id}")
        raise HTTPException(status_code=401, detail="User not registered")
    print(f"[WS] JWT認証成功 external_id={external_id} → uid={user['uid']}")
    return user["uid"]

@router.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket, token: str = Query(...)):
    # 1) 認証
    try:
        uid = await get_uid_from_token(token)
    except Exception:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return

    # 2) 接続承認＆登録
    await websocket.accept()
    active_connections[uid] = websocket

    try:
        while True:
            data = await websocket.receive_json()
            # 型保証
            if not isinstance(data, dict) or "type" not in data:
                continue

            t = data["type"]

            # 3) ping/pong
            if t == "ping":
                await websocket.send_json({"type": "pong"})
                continue

            # 4) 入室通知
            if t == "enter_room":
                room_id = data.get("room_id")
                if room_id:
                    # Redis のセットに追加
                    await redis_client.sadd(f"presence:{room_id}", uid)
                    # ルーム全員に通知
                    await broadcast_event_to_room(room_id, {
                        "type": "user_entered",
                        "room_id": room_id,
                        "uid": uid,
                    })
                continue

            # 5) 退室通知
            if t == "leave_room":
                room_id = data.get("room_id")
                if room_id:
                    await redis_client.srem(f"presence:{room_id}", uid)
                    await broadcast_event_to_room(room_id, {
                        "type": "user_left",
                        "room_id": room_id,
                        "uid": uid,
                    })
                continue

            # ...（必要に応じて他のメッセージにも対応）...
    except WebSocketDisconnect:
        # 切断時に全ルームから削除
        keys = await redis_client.keys("presence:*")
        for key in keys:
            await redis_client.srem(key, uid)
    finally:
        # 接続リストから除外
        if uid in active_connections and active_connections[uid] is websocket:
            del active_connections[uid]

async def send_event(uid: str, event: dict):
    print(f"[WS] send_event called. uid={uid}, event={event}")
    ws = active_connections.get(uid)
    if ws:
        print(f"[WS] send_event: Sending event to active uid={uid}")
        try:
            await ws.send_json(event)
            print(f"[WS] send_event: Successfully sent event to uid={uid}")
        except Exception as e:
            print(f"[WS] send_event: FAILED to send event to uid={uid}, error={e}")
            if uid in active_connections and active_connections[uid] is ws:
                del active_connections[uid]
    else:
        print(f"[WS] send_event: No active connection for uid={uid}")

# 追加場所: src/ws.py の末尾（send_event の下あたり）
# src/ws.py の末尾に追加

async def broadcast_event_to_room(room_id: str, event: dict):
    """ room_id の全 member.uid に send_event を投げる """
    from src.db import db
    room = await db.rooms.find_one({"room_id": room_id, "is_archived": False})
    if not room:
        return
    for m in room.get("members", []):
        await send_event(m["uid"], event)


