--- FILE: ./__init__.py ---



--- FILE: ./api/__init__.py ---



--- FILE: ./api/misc.py ---

# src/api/misc_api.py

from fastapi import APIRouter, Depends, HTTPException
from functools import lru_cache
from datetime import datetime

from src.schemas import (
    SettlementCreate,
    PointRegisterRequest,
    PointInput,
)
from src.utils import get_current_uid
from src.db import get_db, get_redis

from src.repositories.misc_repo import (
    PointRecordRepository,
    SettlementRepository,
    SettlementCacheRepository,
)
from src.repositories.room_repo import RoomRepository
from src.repositories.round_cache_repo import RoundCacheRepository

from src.services.misc_service import (
    PointService,
    SettlementService,
)

from src.ws import send_event, broadcast_event_to_room


router = APIRouter()


# ---- Dependency factories ----

@lru_cache()
def get_point_service() -> PointService:
    mongo = get_db()
    cache = get_redis()
    return PointService(
        point_repo=PointRecordRepository(mongo),
        room_repo=RoomRepository(mongo),
        cache_repo=RoundCacheRepository(cache),
    )

@lru_cache()
def get_settlement_service() -> SettlementService:
    mongo = get_db()
    cache = get_redis()
    return SettlementService(
        settle_repo=SettlementRepository(mongo),
        cache_repo=SettlementCacheRepository(cache),
        point_repo=PointRecordRepository(mongo),
    )


# ---- Point endpoints ----



@router.get("/rooms/{room_id}/points/history")
async def point_history(
    room_id: str,
    service: PointService = Depends(get_point_service),
):
    return await service.history(room_id)




@router.post("/rooms/{room_id}/points/start")
async def start_point_round(
    room_id: str,
    service: PointService = Depends(get_point_service),
):
    await service.start_round(room_id)
    return {"ok": True}


@router.post("/rooms/{room_id}/points/submit")
async def submit_point(
    room_id: str,
    data: PointInput,
    current_uid: str = Depends(get_current_uid),
    service: PointService = Depends(get_point_service),
):
    await service.submit_score(room_id, current_uid, data.value)
    return {"ok": True}


@router.post("/rooms/{room_id}/points/finalize")
async def finalize_point_round(
    room_id: str,
    service: PointService = Depends(get_point_service),
):
    return await service.finalize_round(room_id)




@router.post("/rooms/{room_id}/points/{round_id}/approve")
async def approve_point_record(
    room_id: str,
    round_id: str,
    current_uid: str = Depends(get_current_uid),
    service: PointService = Depends(get_point_service),
):
    await service.approve(room_id, round_id, current_uid)
    return {"ok": True}




@router.get("/users/me/points/history")
async def user_point_history(
    current_uid: str = Depends(get_current_uid),
    service: PointService = Depends(get_point_service),
):
    return await service.history_by_uid(current_uid)


# ---- Settlement endpoints ----


@router.post("/rooms/{room_id}/settle/request")
async def request_settlement(
    room_id: str,
    data: SettlementCreate,
    current_uid: str = Depends(get_current_uid),
    service: SettlementService = Depends(get_settlement_service),
):
    await service.request(room_id, current_uid, data.to_uid, data.amount)
    return {"ok": True}


@router.post("/rooms/{room_id}/settle/request/{from_uid}/approve")
async def approve_settlement_request(
    room_id: str,
    from_uid: str,
    current_uid: str = Depends(get_current_uid),
    service: SettlementService = Depends(get_settlement_service),
):
    await service.approve_request(room_id, from_uid, current_uid)
    return {"ok": True}


@router.post("/rooms/{room_id}/settle/request/{from_uid}/reject")
async def reject_settlement_request(
    room_id: str,
    from_uid: str,
    current_uid: str = Depends(get_current_uid),
    service: SettlementService = Depends(get_settlement_service),
):
    await service.reject_request(room_id, from_uid, current_uid)
    return {"ok": True}


@router.get("/rooms/{room_id}/settle/history")
async def settlement_history(
    room_id: str,
    service: SettlementService = Depends(get_settlement_service),
):
    return await service.history(room_id)





--- FILE: ./api/room.py ---

from fastapi import APIRouter, Depends, HTTPException
from src.services.room_service import RoomService
from src.repositories.room_repo import RoomRepository
from src.repositories.misc_repo import PointRecordRepository
from src.db import get_db ,get_redis
from src.schemas import RoomCreate, RoomResponse, RoomUpdate, ApproveRejectBody
from typing import List
from src.utils import get_current_uid

router = APIRouter()

def get_room_service(db=Depends(get_db)):
    return RoomService(RoomRepository(db), PointRecordRepository(db))

@router.post("/rooms", response_model=dict)
async def create_room(
    data: RoomCreate,
    current_uid: str = Depends(get_current_uid),
    service: RoomService = Depends(get_room_service),
):
    room_id = await service.create_room(current_uid, data.dict())
    return {"room_id": room_id}

@router.get("/rooms", response_model=List[RoomResponse])
async def list_rooms(
    current_uid: str = Depends(get_current_uid),
    service: RoomService = Depends(get_room_service),
):
    return await service.list_user_rooms(current_uid)

@router.get("/rooms/{room_id}/presence", response_model=List[str])
async def get_presence(
    room_id: str,
    current_uid: str = Depends(get_current_uid),
    redis=Depends(get_redis),
):
    key = f"presence:{room_id}"
    members = await redis.smembers(key)
    # 文字列の set を配列にして返却
    return list(members)

@router.get("/rooms/all", response_model=List[RoomResponse])
async def list_all_rooms(
    service: RoomService = Depends(get_room_service)
):
    # すべてのis_archived=Falseなルームを返す
    return await service.list_all_rooms()
@router.get("/rooms/{room_id}", response_model=RoomResponse)
async def get_room(room_id: str, service: RoomService = Depends(get_room_service)):
    return await service.get_room(room_id)

@router.put("/rooms/{room_id}")
async def update_room(
    room_id: str,
    updates: RoomUpdate,
    current_uid: str = Depends(get_current_uid),
    service: RoomService = Depends(get_room_service),
):
    await service.update_room(room_id, updates.dict(exclude_unset=True), current_uid)
    return {"ok": True}

@router.delete("/rooms/{room_id}")
async def delete_room(
    room_id: str,
    current_uid: str = Depends(get_current_uid),
    service: RoomService = Depends(get_room_service),
):
    await service.delete_room(room_id, current_uid)
    return {"ok": True}

@router.post("/rooms/{room_id}/join")
async def join_room(
    room_id: str,
    current_uid: str = Depends(get_current_uid),
    service: RoomService = Depends(get_room_service)
):
    await service.request_join(room_id, current_uid)
    return {"ok": True}

@router.post("/rooms/{room_id}/cancel_join")
async def cancel_join_request(
        room_id:str,
        current_uid: str = Depends(get_current_uid),
        services: RoomService = Depends(get_room_service),
):
    await services.cancel_join_request(room_id, current_uid)
    return {"ok": True}


@router.post("/rooms/{room_id}/approve")
async def approve_member(
    room_id: str,
    body: ApproveRejectBody,
    current_uid: str = Depends(get_current_uid),
    service: RoomService = Depends(get_room_service)
):
    await service.approve_member(room_id, body.applicant_user_id, current_uid)
    return {"ok": True}

@router.post("/rooms/{room_id}/reject")
async def reject_member(
    room_id: str,
    body: ApproveRejectBody,
    current_uid: str = Depends(get_current_uid),
    service: RoomService = Depends(get_room_service)
):
    await service.reject_member(room_id, body.applicant_user_id, current_uid)
    return {"ok": True}

@router.post("/rooms/{room_id}/leave")
async def leave_room(
    room_id: str,
    current_uid: str = Depends(get_current_uid),
    service: RoomService = Depends(get_room_service)
):
    await service.leave_room(room_id, current_uid)
    return {"ok": True}



--- FILE: ./api/user.py ---

from fastapi import APIRouter, Depends, HTTPException
from src.services.user_service import UserService
from src.repositories.user_repo import UserRepository
from src.repositories.room_repo import RoomRepository
from src.db import get_db
from src.schemas import UserCreate, UserUpdate, UserResponse
from typing import List
from src.utils import get_current_uid, get_current_external_id
from src.ws import active_connections

router = APIRouter()



def get_user_service(db=Depends(get_db)):
    return UserService(UserRepository(db), RoomRepository(db))

@router.get("/users", response_model=List[UserResponse])
async def list_users(
    with_online: int = 0,
    service: UserService = Depends(get_user_service)
):
    users = await service.list_users()
    if with_online:
        # uidで比較し、is_onlineを動的付与
        for u in users:
            u["is_online"] = u["uid"] in active_connections
    return users

@router.post("/users", response_model=UserResponse)
async def create_user(
    user: UserCreate,
    external_id: str = Depends(get_current_external_id),
    service: UserService = Depends(get_user_service)
):
    return await service.create_user(user.dict(), external_id)

@router.get("/users/me", response_model=UserResponse)
async def get_me(
    current_uid: str = Depends(get_current_uid),   # ← ここ
    service: UserService = Depends(get_user_service)
):
    return await service.get_user(current_uid)

@router.put("/users/me", response_model=dict)
async def update_me(
    data: UserUpdate,
    current_uid: str = Depends(get_current_uid),   # ← ここ
    service: UserService = Depends(get_user_service)
):
    await service.update_display_name(current_uid, data.display_name)
    return {"ok": True}




--- FILE: ./config.py ---

import os

from dotenv import load_dotenv
load_dotenv()  # .envファイルを自動で読み込む

MONGODB_URI = os.getenv("MONGODB_URI", "mongodb://satopon_mongo:27017")
REDIS_URI = os.getenv("REDIS_URI", "redis://satopon_redis:6379/0")
MONGO_DB_NAME = os.getenv("MONGO_DB_NAME", "satopon")
JWT_SECRET = os.getenv("JWT_SECRET", "satopon-secret")
ALLOWED_ORIGINS = os.getenv("ALLOWED_ORIGINS", "*")

# 認証プロバイダ種別（supabase or firebase）
AUTH_PROVIDER = os.getenv("AUTH_PROVIDER", "supabase")

# 各プロバイダ個別の秘密鍵や設定も追加
SUPABASE_JWT_SECRET = os.getenv("SUPABASE_JWT_SECRET", None)
FIREBASE_PROJECT_ID = os.getenv("FIREBASE_PROJECT_ID", None)

# 例: どちらも存在しない場合はエラー出すなど、ここで制御できる
if AUTH_PROVIDER == "supabase" and not SUPABASE_JWT_SECRET:
    raise RuntimeError("SUPABASE_JWT_SECRET is required for Supabase auth")
if AUTH_PROVIDER == "firebase" and not FIREBASE_PROJECT_ID:
    raise RuntimeError("FIREBASE_PROJECT_ID is required for Firebase auth")


--- FILE: ./db.py ---

# src/db.py

import os
from motor.motor_asyncio import AsyncIOMotorClient
import redis.asyncio as redis  # redis-py公式の非同期クライアント

from .config import MONGODB_URI, MONGO_DB_NAME, REDIS_URI

# MongoDB
_mongo_client = AsyncIOMotorClient(MONGODB_URI)
db = _mongo_client[MONGO_DB_NAME]

# Redis
redis_client = redis.from_url(REDIS_URI, decode_responses=True)

def get_db():
    return db

def get_redis():
    return redis_client


--- FILE: ./main.py ---

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from motor.motor_asyncio import AsyncIOMotorClient
from src.api import user, room, misc
from .config import MONGODB_URI, MONGO_DB_NAME
from src.db import get_db
import os
from src import ws


      #allow_origins=["http://localhost","http://localhost:3000"],
# FastAPI app設定など
app = FastAPI()

# CORS
app.add_middleware(
      CORSMiddleware,
      allow_origins=["*"],
      allow_credentials=True,
      allow_methods=["*"],
      allow_headers=["*"],
)

app.include_router(user.router, prefix="/api", tags=["user"])
app.include_router(room.router, prefix="/api", tags=["room"])
app.include_router(misc.router, prefix="/api", tags=["misc"])
app.include_router(ws.router)

# WebSocketやイベントも後述



--- FILE: ./models.py ---

from pydantic import BaseModel, Field, EmailStr
from typing import List, Optional
from datetime import datetime

# --- User ---
class UserModel(BaseModel):
    uid: str                   # 内部主キー
    external_id: str           # sub（supabaseやfirebaseのsub）
    display_name: str
    email: EmailStr
    icon_url: Optional[str] = None
    registered_at: datetime
    is_deleted: bool = False

# --- Room ---
class MemberObj(BaseModel):
    uid: str
    joined_at: datetime

class PendingMemberObj(BaseModel):
    uid: str
    requested_at: datetime

class RoomModel(BaseModel):
    room_id: str
    name: str
    description: Optional[str] = None
    color_id: int
    created_by: str
    created_at: datetime
    is_archived: bool = False
    members: List[MemberObj] = []
    pending_members: List[PendingMemberObj] = [] 

# --- PointRecord ---
class PointObj(BaseModel):
    uid: str
    value: int

class PointRecordModel(BaseModel):
    room_id: str
    round_id: str
    points: List[PointObj]
    created_at: datetime
    approved_by: List[str]
    is_deleted: bool = False

# --- Settlement ---
class SettlementModel(BaseModel):
    room_id: str
    from_uid: str
    to_uid: str
    amount: int
    approved: bool
    created_at: datetime
    approved_at: Optional[datetime] = None
    is_deleted: bool = False



--- FILE: ./repositories/__init__.py ---



--- FILE: ./repositories/misc_repo.py ---

# src/repositories/misc_repo.py

from motor.motor_asyncio import AsyncIOMotorDatabase
from typing import List, Optional
from datetime import datetime
from bson import ObjectId
import redis.asyncio as redis


class PointRecordRepository:
    def __init__(self, db: AsyncIOMotorDatabase):
        self.collection = db.point_records

    async def create(self, data: dict) -> str:
        data.setdefault("created_at", datetime.now())
        data.setdefault("is_deleted", False)
        await self.collection.insert_one(data)
        return data["round_id"]

    async def history(self, room_id: str) -> List[dict]:
        cursor = self.collection.find(
            {"room_id": room_id, "is_deleted": False}
        )
        items = await cursor.to_list(length=100)
        for item in items:
            # ObjectId を取り除く
            item.pop("_id", None)
        return items


class SettlementRepository:
    def __init__(self, db: AsyncIOMotorDatabase):
        self.collection = db.settlements



    async def history(self, room_id: str) -> List[dict]:
        cursor = self.collection.find(
            {"room_id": room_id, "is_deleted": False}
        )
        items = await cursor.to_list(length=100)
        for item in items:
            item["settlement_id"] = str(item.pop("_id"))
        return items

    async def history_by_uid(self, uid: str) -> List[dict]:
        cursor = self.collection.find({
            "$or": [{"from_uid": uid}, {"to_uid": uid}],
            "is_deleted": False
        })
        items = await cursor.to_list(length=100)
        for item in items:
            item["settlement_id"] = str(item.pop("_id"))
        return items


class SettlementCacheRepository:
    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client

    def _key(self, room_id: str, from_uid: str, to_uid: str) -> str:
        return f"settle:{room_id}:{from_uid}->{to_uid}"

    async def cache_request(self, room_id: str, from_uid: str, to_uid: str, amount: int) -> None:
        k = self._key(room_id, from_uid, to_uid)
        await self.redis.hset(k, mapping={
            "room_id": room_id,
            "from_uid": from_uid,
            "to_uid": to_uid,
            "amount": amount,
        })
        await self.redis.expire(k, 180)

    async def get_request(self, room_id: str, from_uid: str, to_uid: str):
        k = self._key(room_id, from_uid, to_uid)
        data = await self.redis.hgetall(k)
        # decode_responses=True の場合は str キー／値なので 'amount' でチェック
        if not data or "amount" not in data:
            return None
        return {
            "room_id": data["room_id"],
            "from_uid": data["from_uid"],
            "to_uid": data["to_uid"],
            "amount": int(data["amount"]),
        }
    async def clear_request(self, room_id: str, from_uid: str, to_uid: str) -> None:
        k = self._key(room_id, from_uid, to_uid)
        await self.redis.delete(k)


class RoundCacheRepository:
    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client

    def _prefix(self, room_id: str) -> str:
        return f"points:{room_id}"

    async def start(self, room_id: str, round_id: str, participants: list[str]) -> None:
        """
        participants: ラウンド開始時に在室していたユーザーUIDリスト
        """
        p = self._prefix(room_id)
        # round_id と開始時参加者を保存
        await self.redis.hset(p, mapping={
           "round_id":    round_id,
            "participants": ",".join(participants),
        })
        await self.redis.delete(f"{p}:submissions", f"{p}:approvals")
    async def get_round_id(self, room_id: str) -> Optional[str]:
        val = await self.redis.hget(self._prefix(room_id), "round_id")
        return val.decode() if val else None

    async def add_submission(self, room_id: str, uid: str, value: int) -> Optional[str]:
        p = self._prefix(room_id)
        round_id = await self.get_round_id(room_id)
        if not round_id:
            return None
        await self.redis.hset(f"{p}:submissions", uid, value)
        return round_id

    async def get_submissions(self, room_id: str) -> dict[str, int]:
        data = await self.redis.hgetall(f"{self._prefix(room_id)}:submissions")
        return {k.decode(): int(v) for k, v in data.items()}

    async def add_approval(self, room_id: str, uid: str) -> None:
        await self.redis.sadd(f"{self._prefix(room_id)}:approvals", uid)

    async def get_approvals(self, room_id: str) -> List[str]:
        members = await self.redis.smembers(f"{self._prefix(room_id)}:approvals")
        return [m.decode() for m in members]

    async def clear(self, room_id: str) -> None:
        p = self._prefix(room_id)
        await self.redis.delete(p, f"{p}:submissions", f"{p}:approvals")


--- FILE: ./repositories/room_repo.py ---

from motor.motor_asyncio import AsyncIOMotorDatabase
from typing import Optional, List
from datetime import datetime

class RoomRepository:
    def __init__(self, db: AsyncIOMotorDatabase):
        self.collection = db.rooms

    async def exists(self, room_id: str) -> bool:
        doc = await self.collection.find_one({"room_id": room_id, "is_archived": False})
        return doc is not None

    async def create(self, data: dict) -> str:
        data["created_at"] = datetime.now()
        data["is_archived"] = False
        await self.collection.insert_one(data)
        return data["room_id"]

    async def get_by_id(self, room_id: str) -> Optional[dict]:
        doc = await self.collection.find_one({"room_id": room_id, "is_archived": False})
        if doc is not None and "pending_members" not in doc:
            doc["pending_members"] = []
        return doc

    async def list_all(self) -> List[dict]:
        cursor = self.collection.find({"is_archived": False})
        return await cursor.to_list(length=1000)

    async def update(self, room_id: str, updates: dict) -> bool:
        result = await self.collection.update_one(
            {"room_id": room_id, "is_archived": False}, {"$set": updates}
        )
        return result.modified_count == 1

    async def list_rooms_for_user(self, uid: str) -> List[dict]:
        cursor = self.collection.find({"members.uid": uid, "is_archived": False})
        return await cursor.to_list(length=100)

    async def add_member(self, room_id: str, uid: str):
        await self.collection.update_one(
            {"room_id": room_id, "is_archived": False, "members.uid": {"$ne": uid}},
            {"$push": {"members": {"uid": uid, "joined_at": datetime.now()}}}
        )
    async def add_pending_member(self, room_id: str, uid: str):
        await self.collection.update_one(
            {"room_id": room_id, "is_archived": False},
            {"$push": {"pending_members": {"uid": uid, "requested_at": datetime.now()}}}
        )

    async def approve_pending_member(self, room_id: str, uid: str) -> bool:
        result = await self.collection.update_one(
            {
                "room_id": room_id,
                "is_archived": False,
                "pending_members.uid": uid  # まだpendingな場合だけpull/push
            },
            {
                "$pull": {"pending_members": {"uid": uid}},
                "$push": {"members": {"uid": uid, "joined_at": datetime.now()}}
            }
        )
        return result.modified_count == 1
    # remove_pending_member
    async def remove_pending_member(self, room_id: str, uid: str) -> bool:
        result = await self.collection.update_one(
            {
                "room_id": room_id,
                "is_archived": False,
                "pending_members.uid": uid  # まだpendingな場合だけpull
            },
            {"$pull": {"pending_members": {"uid": uid}}}
        )
        return result.modified_count == 1

    async def remove_member(self, room_id: str, uid: str):
        await self.collection.update_one(
            {"room_id": room_id, "is_archived": False},
            {"$pull": {"members": {"uid": uid}}}
        )


--- FILE: ./repositories/round_cache_repo.py ---

# src/repositories/round_cache_repo.py

class RoundCacheRepository:
    def __init__(self, redis):
        self.redis = redis

    def _round_key(self, room_id: str) -> str:
        return f"round:{room_id}"

    def _subs_key(self, room_id: str) -> str:
        return f"{self._round_key(room_id)}:subs"

    def _approvals_key(self, room_id: str) -> str:
        return f"{self._round_key(room_id)}:apprs"

    async def start(
        self,
        room_id: str,
        round_id: str,
        participants: list[str],
        ttl: int = 180,
    ) -> None:
        """
        ラウンドIDと開始時参加者リストを保存し、
        各キーにTTLを設定します。
        """
        key = self._round_key(room_id)
        await self.redis.hset(
            key,
            mapping={
                "round_id":     round_id,
                "participants": ",".join(participants),
            },
        )
        # TTL をセット
        await self.redis.expire(key, ttl)
        await self.redis.expire(self._subs_key(room_id), ttl)
        await self.redis.expire(self._approvals_key(room_id), ttl)
    async def get_round_id(self, room_id: str) -> str | None:
        # 現在のラウンドIDを取得
        return await self.redis.hget(self._round_key(room_id), "round_id")

    async def add_submission(self, room_id: str, uid: str, value: int, ttl: int = 180) -> str | None:
        # スコアを記録し、TTLをリフレッシュ
        await self.redis.hset(self._subs_key(room_id), uid, value)
        await self.redis.expire(self._subs_key(room_id), ttl)
        # ラウンドIDもTTLリフレッシュ
        await self.redis.expire(self._round_key(room_id), ttl)
        return await self.get_round_id(room_id)

    async def get_submissions(self, room_id: str) -> dict[str, int]:
        raw = await self.redis.hgetall(self._subs_key(room_id))
        return {k: int(v) for k, v in raw.items()}

    async def add_approval(self, room_id: str, uid: str, ttl: int = 180) -> None:
        await self.redis.sadd(self._approvals_key(room_id), uid)
        await self.redis.expire(self._approvals_key(room_id), ttl)
        await self.redis.expire(self._round_key(room_id), ttl)

    async def get_approvals(self, room_id: str) -> set[str]:
        return await self.redis.smembers(self._approvals_key(room_id))

    async def get_participants(self, room_id: str) -> list[str]:
        key = self._round_key(room_id)
        raw = await self.redis.hget(key, "participants")
        if not raw:
            return []
        return raw.split(",")

    async def clear(self, room_id: str) -> None:
        # ラウンド関連キーをすべて削除
        await self.redis.delete(
            self._round_key(room_id),
            self._subs_key(room_id),
            self._approvals_key(room_id),
        )


--- FILE: ./repositories/user_repo.py ---

from src.models import UserModel
from motor.motor_asyncio import AsyncIOMotorDatabase
from typing import Optional, List
from datetime import datetime

class UserRepository:
    def __init__(self, db: AsyncIOMotorDatabase):
        self.collection = db.users

    async def get_by_uid(self, uid: str) -> Optional[dict]:
        return await self.collection.find_one({"uid": uid, "is_deleted": False})

    async def get_by_external_id(self, external_id: str) -> Optional[dict]:
        return await self.collection.find_one({"external_id": external_id, "is_deleted": False})

    async def create(self, data: dict) -> str:
        data["registered_at"] = datetime.now()
        data["is_deleted"] = False
        await self.collection.insert_one(data)
        return data["uid"]

    async def update_display_name(self, uid: str, display_name: str) -> bool:
        result = await self.collection.update_one(
            {"uid": uid, "is_deleted": False},
            {"$set": {"display_name": display_name}}
        )
        return result.modified_count == 1

    async def list_all(self) -> List[dict]:
        cursor = self.collection.find({"is_deleted": False})
        return await cursor.to_list(length=1000)




--- FILE: ./schemas.py ---

# src/schemas.py

from pydantic import BaseModel, EmailStr
from typing import List, Optional
from datetime import datetime

# --- User ---
class UserCreate(BaseModel):
    display_name: str
    email: EmailStr
    icon_url: Optional[str] = None

class UserResponse(BaseModel):
    uid: str
    display_name: str
    icon_url: Optional[str]
    registered_at: datetime
    is_online: Optional[bool] = None   # 追加

class UserUpdate(BaseModel):
    display_name: str

# --- Room ---
class RoomCreate(BaseModel):
    name: str
    description: Optional[str] = None
    color_id: int

class RoomUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    color_id: Optional[int] = None

class RoomResponse(BaseModel):
    room_id: str
    name: str
    description: Optional[str]
    color_id: int
    created_by: str
    created_at: datetime
    is_archived: bool
    members: List[dict]
    pending_members: List[dict]   # ←これを追加

class ApproveRejectBody(BaseModel):
    applicant_user_id: str

# --- Point ---
class PointInput(BaseModel):
    uid: str
    value: int

class PointRegisterRequest(BaseModel):
    points: List[PointInput]
    approved_by: List[str]

class PointHistoryResponse(BaseModel):
    round_id: str
    points: List[PointInput]
    created_at: datetime
    approved_by: List[str]
    is_deleted: bool
    _id: Optional[str]

# --- Settlement ---
class SettlementCreate(BaseModel):
    to_uid: str
    amount: int

class SettlementHistoryResponse(BaseModel):
    from_uid: str
    to_uid: str
    amount: int
    approved: bool
    created_at: datetime
    approved_at: Optional[datetime]
    is_deleted: bool


--- FILE: ./services/__init__.py ---



--- FILE: ./services/misc_service.py ---

# src/services/misc_service.py

import asyncio
from datetime import datetime
from fastapi import HTTPException

from src.repositories.misc_repo import (
    PointRecordRepository,
    SettlementRepository,
    SettlementCacheRepository,
    RoundCacheRepository,
)
from src.repositories.room_repo import RoomRepository
from src.ws import broadcast_event_to_room, send_event

def _make_round_id(prefix: str, length: int = 6) -> str:
    import random, string
    chars = string.ascii_uppercase + string.digits
    rnd = ''.join(random.choices(chars, k=length))
    return f"{prefix}-{rnd}"


class PointService:
    def __init__(
        self,
        point_repo: PointRecordRepository,
        room_repo: RoomRepository,
        cache_repo,  # RoundCacheRepository
    ):
        self.point_repo = point_repo
        self.room_repo = room_repo
        self.cache = cache_repo
        self._timeout_tasks: dict[str, asyncio.Task] = {}

    # ─── ユースケースメソッド ───

    async def history(self, room_id: str):
        return await self.point_repo.history(room_id)



    async def start_round(self, room_id: str):
        room = await self.room_repo.get_by_id(room_id)
        if not room:
             raise HTTPException(404, "Room not found")
 
        # ——— 在室ユーザー一覧を Redis から取得 ———
        presence_key = f"presence:{room_id}"
        participants = await self.cache.redis.smembers(presence_key)
        participants = list(participants)
        if len(participants) < 2:
            raise HTTPException(400, "Need 2+ users to start round")

        # キャッシュ初期化・新ラウンドID生成
        await self.cache.clear(room_id)
        round_id = _make_round_id("PON")
        await self.cache.start(room_id, round_id, participants)
        if task := self._timeout_tasks.get(room_id):
            task.cancel()
        self._timeout_tasks[room_id] = asyncio.create_task(self._watch_timeout(room_id))

        await broadcast_event_to_room(room_id, {
            "type": "point_round_started",
            "room_id": room_id,
            "round_id": round_id,
        })

    async def submit_score(self, room_id: str, uid: str, value: int):
        round_id = await self.cache.add_submission(room_id, uid, value)
        if not round_id:
            raise HTTPException(400, "No active round")

        await broadcast_event_to_room(room_id, {
            "type": "point_submitted",
            "room_id": room_id,
            "round_id": round_id,
            "uid": uid,
        })

        subs = await self.cache.get_submissions(room_id)
        round_meta_key = self.cache._round_key(room_id)
        meta = await self.cache.redis.hgetall(round_meta_key)
        start_participants = meta.get("participants", "").split(",")
        if len(subs) == len(start_participants):# タイマー取消
            if task := self._timeout_tasks.pop(room_id, None):
                task.cancel()

            total = sum(subs.values())
            if total != 0:
                await broadcast_event_to_room(room_id, {
                    "type": "point_round_cancelled",
                    "room_id": room_id,
                    "round_id": round_id,
                    "reason": "Sum is not zero",
                })
                await self.cache.clear(room_id)
            else:
                # 最終表通知のみ（DB登録は approve 時にまとめて）
                await broadcast_event_to_room(room_id, {
                    "type": "point_final_table",
                    "room_id": room_id,
                    "round_id": round_id,
                    "table": subs,
                })

    async def finalize_round(self, room_id: str):
        subs = await self.cache.get_submissions(room_id)
        if not subs:
            raise HTTPException(400, "No active round")

        total = sum(subs.values())
        round_id = await self.cache.get_round_id(room_id)
        if total != 0:
            await self.cancel_round(room_id, reason="Sum is not zero")
            raise HTTPException(400, "Sum is not zero")

        await broadcast_event_to_room(room_id, {
            "type": "point_final_table",
            "room_id": room_id,
            "round_id": round_id,
            "table": subs,
        })
        return {"round_id": round_id, "table": subs}

    async def approve(self, room_id: str, round_id: str, current_uid: str):
        await self.cache.add_approval(room_id, current_uid)
        approvals = set(await self.cache.get_approvals(room_id))

        participants = await self.cache.get_participants(room_id)
        members = set(participants)

        await broadcast_event_to_room(room_id, {
            "type": "point_approved",
            "room_id": room_id,
            "round_id": round_id,
            "uid": current_uid,
        })

        # 全員承認なら DB 永続化
        if approvals | {current_uid} == members:
            subs = await self.cache.get_submissions(room_id)
            await self.point_repo.create({
                "room_id": room_id,
                "round_id": round_id,
                "points": [{"uid": k, "value": v} for k, v in subs.items()],
                "approved_by": list(members),
                "created_at": datetime.now(),
                "is_deleted": False,
            })
            await self.cache.clear(room_id)
            await broadcast_event_to_room(room_id, {
                "type": "point_fully_approved",
                "room_id": room_id,
                "round_id": round_id,
                "approved_by": list(members),
            })


    async def cancel_round(self, room_id: str, reason: str):
        round_id = await self.cache.get_round_id(room_id)
        if task := self._timeout_tasks.pop(room_id, None):
            task.cancel()

        await broadcast_event_to_room(room_id, {
            "type": "point_round_cancelled",
            "room_id": room_id,
            "round_id": round_id,
            "reason": reason,
        })
        await self.cache.clear(room_id)

    # ─── 内部ユーティリティ ───

    async def _watch_timeout(self, room_id: str):
        try:
            await asyncio.sleep(180)
            await self.cancel_round(room_id, reason="Timeout after 3 minutes")
        except asyncio.CancelledError:
            pass


class SettlementService:
    def __init__(
        self,
        settle_repo: SettlementRepository,
        cache_repo: SettlementCacheRepository,
        point_repo: PointRecordRepository,
    ):
        self.settle_repo = settle_repo
        self.cache = cache_repo
        self.point_repo = point_repo


    async def request(self, room_id: str, from_uid: str, to_uid: str, amount: int):
        # 1) 既存リクエストの存在チェック
        exists = await self.cache.get_request(room_id, from_uid, to_uid)
        if exists:
            raise HTTPException(400, "既にリクエスト中です")

        # 2) キャッシュ登録 + TTL
        await self.cache.cache_request(room_id, from_uid, to_uid, amount)

        # 3) 通知
        await send_event(to_uid, {
            "type": "settle_requested",
            "room_id": room_id,
            "from_uid": from_uid,
            "to_uid": to_uid,
            "amount": amount,
        })

    async def approve_request(self, room_id: str, from_uid: str, to_uid: str):
        # キャッシュ取得
        req = await self.cache.get_request(room_id, from_uid, to_uid)
        if not req:
            raise HTTPException(404, "リクエストが見つからないか期限切れです")
        amount = req["amount"]

        # 残高検証
        await self._validate_balances(from_uid, to_uid, amount)

        # 永続化（PointRecord に２エントリ）
        round_id = _make_round_id("SATO")
        await self.point_repo.create({
            "room_id": room_id,
            "round_id": round_id,
            "points": [
                {"uid": from_uid,   "value": amount},
                {"uid": to_uid,     "value": -amount},
            ],
            "approved_by": [from_uid, to_uid],
            "created_at": datetime.now(),
            "is_deleted": False,
        })

        await self.cache.clear_request(room_id, from_uid, to_uid)
        await broadcast_event_to_room(room_id, {
            "type": "settle_completed",
            "room_id": room_id,
            "from_uid": from_uid,
            "to_uid": to_uid,
            "amount": amount,
        })

        return round_id

    async def reject_request(self, room_id: str, from_uid: str, to_uid: str):
        await self.cache.clear_request(room_id, from_uid, to_uid)
        payload = {
            "type": "settle_rejected",
            "room_id": room_id,
            "from_uid": from_uid,
            "to_uid": to_uid,
        }
        await send_event(from_uid, payload)
        await broadcast_event_to_room(room_id, payload)

    async def history(self, room_id: str):
        return await self.settle_repo.history(room_id)

    async def history_by_uid(self, uid: str):
        return await self.settle_repo.history_by_uid(uid)

    # ─── 内部ユーティリティ ───

    async def _validate_balances(self, from_uid: str, to_uid: str, amount: int):
        bal_from = await self._get_balance(from_uid)
        if bal_from + amount > 0:
            raise HTTPException(400, "送信元の残高不足です")

        bal_to = await self._get_balance(to_uid)
        if bal_to - amount < 0:
            raise HTTPException(400, "受信側の残高制限を超えます")

    async def _get_balance(self, uid: str) -> int:
        hist = await self.point_repo.history_by_uid(uid)
        return sum(
            p["value"]
            for rec in hist
            for p in rec["points"]
            if p["uid"] == uid
        )


--- FILE: ./services/room_service.py ---

from src.repositories.room_repo import RoomRepository
from src.repositories.misc_repo import PointRecordRepository
from fastapi import HTTPException
from datetime import datetime
import uuid
from src.ws import send_event, broadcast_event_to_room 
import random
import string
import asyncio

def generate_room_id(length=5):
    chars = string.ascii_uppercase + string.digits  # 例：A-Z, 0-9
    return ''.join(random.choices(chars, k=length))



class RoomService:
    def __init__(self, room_repo: RoomRepository, point_repo: PointRecordRepository):
        self.room_repo = room_repo
        self.point_repo = point_repo
        self.pending_timers = {}

    async def create_room(self, uid: str, data: dict):
        name = data.get("name", "")
        if not (1 <= len(name) <= 20):
            raise HTTPException(status_code=400, detail="ルーム名は1〜20文字で指定してください")

        while True:
            room_id = generate_room_id(5)
            if not await self.room_repo.exists(room_id):
                break

        payload = {
            "room_id": room_id,
            "name": data["name"],
            "description": data.get("description"),
            "color_id": data["color_id"],
            "created_by": uid,
            "created_at": datetime.now(),
            "is_archived": False,
            "members": [{"uid": uid, "joined_at": datetime.now()}],
            "pending_members": []
        }
        await self.room_repo.create(payload)
        return room_id

    async def get_room(self, room_id: str):
        room = await self.room_repo.get_by_id(room_id)
        if not room:
            raise HTTPException(status_code=404, detail="Room not found")
        return room
    async def list_all_rooms(self):
        return await self.room_repo.list_all()

    async def list_user_rooms(self, uid: str):
        return await self.room_repo.list_rooms_for_user(uid)

    async def update_room(self, room_id: str, updates: dict, current_uid: str):

        if "name" in updates:
            name = updates["name"] or ""
            if not (1 <= len(name) <= 20):
                raise HTTPException(status_code=400, detail="ルーム名は1〜20文字で指定してください")
        room = await self.room_repo.get_by_id(room_id)

        if not room:
            raise HTTPException(status_code=404, detail="Room not found")
        if room["created_by"] != current_uid:
            raise HTTPException(status_code=403, detail="Not allowed to update this room")
        return await self.room_repo.update(room_id, updates)

    async def delete_room(self, room_id: str, current_uid: str):
        room = await self.room_repo.get_by_id(room_id)
        if not room:
            raise HTTPException(status_code=404, detail="Room not found")
        if room["created_by"] != current_uid:
            raise HTTPException(status_code=403, detail="Not allowed to delete this room")

        # --- 全員ポイント残高チェック ---
        point_histories = await self.point_repo.history(room_id)
        balances = {}
        for record in point_histories:
            if record.get("is_deleted"):
                continue
            for pt in record.get("points", []):
                uid = pt["uid"]
                balances[uid] = balances.get(uid, 0) + pt["value"]
        for member in room.get("members", []):
            if balances.get(member["uid"], 0) != 0:
                raise HTTPException(status_code=400, detail="ルームメンバーにポイント残高があるため削除不可")
        # 論理削除
        return await self.room_repo.update(room_id, {"is_archived": True})

    async def join_room(self, room_id: str, uid: str):
        room = await self.room_repo.get_by_id(room_id)
        if not room:
            raise HTTPException(status_code=404, detail="Room not found")
        if any(m["uid"] == uid for m in room.get("members", [])):
            return True
        await self.room_repo.add_member(room_id, uid)
        return True

    async def request_join(self, room_id: str, applicant_uid: str):
        room = await self.room_repo.get_by_id(room_id)
        if any(m["uid"] == applicant_uid for m in room.get("members", [])):
            raise HTTPException(status_code=400, detail="Already a member")
        if any(m["uid"] == applicant_uid for m in room.get("pending_members", [])):
            raise HTTPException(status_code=400, detail="Already requested")
        await self.room_repo.add_pending_member(room_id, applicant_uid)
        for member in room["members"]:
            await send_event(member["uid"], {"type": "join_request", "room_id": room_id, "applicant_uid": applicant_uid})
        key = f"{room_id}:{applicant_uid}"
        if key in self.pending_timers:
            self.pending_timers[key].cancel()
        self.pending_timers[key] = asyncio.create_task(
            self._auto_cancel_join_request(room_id, applicant_uid, key)
        )
    
    async def _auto_cancel_join_request(self, room_id, applicant_uid, key):
        try:
            await asyncio.sleep(30)
            room = await self.room_repo.get_by_id(room_id)
            if any(m["uid"] == applicant_uid for m in room.get("pending_members", [])):
                await self.cancel_join_request(room_id, applicant_uid)
        except asyncio.CancelledError:
            pass
        finally:
            self.pending_timers.pop(key, None)

    def _cancel_pending_timer(self, room_id, applicant_uid):
        key = f"{room_id}:{applicant_uid}"
        task = self.pending_timers.pop(key, None)
        if task:
            task.cancel()

    # approve_member
    async def approve_member(self, room_id: str, applicant_uid: str, approver_uid: str):
        room = await self.room_repo.get_by_id(room_id)
        if not any(m["uid"] == approver_uid for m in room["members"]):
            raise HTTPException(status_code=403, detail="No permission")
        ok = await self.room_repo.approve_pending_member(room_id, applicant_uid)
        if not ok:
            raise HTTPException(status_code=400, detail="Already processed or not pending")
        await send_event(applicant_uid, {"type": "join_approved", "room_id": room_id})
        await broadcast_event_to_room(room_id, {
            "type": "join_approved",
            "room_id": room_id,
            "applicant_uid": applicant_uid,
        })
        self._cancel_pending_timer(room_id, applicant_uid)


    # cancel_join_request
    async def cancel_join_request(self, room_id: str, user_id: str):
        room = await self.room_repo.get_by_id(room_id)
        if not room:
            raise HTTPException(status_code=404, detail="Room not found")
        ok = await self.room_repo.remove_pending_member(room_id, user_id)
        if not ok:
            raise HTTPException(status_code=400, detail="Not in pending list or already processed")
        for m in room["members"]:
            await send_event(m["uid"], {"type": "join_request_cancelled", "room_id": room_id, "user_id": user_id})
        await send_event(user_id, {"type": "join_request_cancelled", "room_id": room_id, "user_id": user_id})
        self._cancel_pending_timer(room_id, user_id)
    
    # reject_member
    async def reject_member(self, room_id: str, applicant_uid: str, approver_uid: str):
        room = await self.room_repo.get_by_id(room_id)
        if not any(m["uid"] == approver_uid for m in room["members"]):
            raise HTTPException(status_code=403, detail="No permission")
        ok = await self.room_repo.remove_pending_member(room_id, applicant_uid)
        if not ok:
            raise HTTPException(status_code=400, detail="Already processed or not pending")
        event_payload = {
            "type": "join_rejected",
            "room_id": room_id,
            "applicant_uid": applicant_uid
        }
        await broadcast_event_to_room(room_id, event_payload)
        await send_event(applicant_uid, event_payload)
        self._cancel_pending_timer(room_id, applicant_uid)
    
    async def leave_room(self, room_id: str, uid: str):
        room = await self.room_repo.get_by_id(room_id)
        if not room:
            raise HTTPException(status_code=404, detail="Room not found")
        if room["created_by"] == uid:
            # 自分以外にメンバーがいるなら退会不可
            members = [m for m in room.get("members", []) if m["uid"] != uid]
            if members:
                raise HTTPException(status_code=400, detail="ルーム作成者は他のメンバーがいる間は退会できません")
            # 作成者1人だけなら→退会＝削除で良い（バリデーションはdelete_roomのロジックでOK）
            await self.delete_room(room_id, uid)
            return True
        balance = 0
        from collections import defaultdict
        point_histories = await self.point_repo.history(room_id)
        for record in point_histories:
            if record.get("is_deleted"): continue
            for pt in record.get("points", []):
                if pt["uid"] == uid:
                    balance += pt["value"]
        if balance != 0:
            raise HTTPException(status_code=400, detail="ポイント残高が0でないため退会不可")
        await self.room_repo.remove_member(room_id, uid)
        return True


--- FILE: ./services/user_service.py ---

import random
import string
from src.repositories.user_repo import UserRepository
from src.repositories.room_repo import RoomRepository
from fastapi import HTTPException

def generate_uid(length=8):
    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

class UserService:
    def __init__(self, repo: UserRepository, room_repo: RoomRepository):
        self.repo = repo
        self.room_repo = room_repo

    # JWTのsub or uid = external_id として渡される
    async def create_user(self, user_data: dict, external_id: str):
        user_data = user_data.copy()
        user_data["external_id"] = external_id

    # まずactiveなユーザーを探す
        exists = await self.repo.get_by_external_id(external_id)
        if exists:
            return exists

    # 論理削除ユーザーを復活させる
        deleted_user = await self.repo.collection.find_one({"external_id": external_id, "is_deleted": True})
        if deleted_user:
            await self.repo.collection.update_one(
                {"external_id": external_id},
                {"$set": {**user_data, "is_deleted": False}}
            )
            return await self.repo.get_by_external_id(external_id)

    # どちらもいなければ新規
        uid = generate_uid()
        while await self.repo.get_by_uid(uid):
            uid = generate_uid()
        user_data["uid"] = uid

        await self.repo.create(user_data)
        return await self.repo.get_by_uid(uid)

    # DB主キーuidで取得
    async def get_user(self, uid: str):
        user = await self.repo.get_by_uid(uid)
        if not user:
            raise Exception("User not found")
        return user


    async def update_display_name(self, uid: str, display_name: str):
        ok = await self.repo.update_display_name(uid, display_name)
        if not ok:
            raise HTTPException(status_code=404, detail="User not found or already deleted")
        return ok

    async def list_users(self):
        users = await self.repo.list_all()
        # email以外を抽出して新しいdictを作る
        result = [
            {k: v for k, v in user.items() if k != "email"}
            for user in users
        ]
        return result
 





--- FILE: ./utils.py ---

import logging
from fastapi import Request, HTTPException, status, Depends
from jose import jwt
from src.config import AUTH_PROVIDER, SUPABASE_JWT_SECRET, FIREBASE_PROJECT_ID
from src.db import get_db

# Supabase 用
#   jose.jwt.decode

# Firebase 用
from google.oauth2 import id_token
from google.auth.transport.requests import Request as GoogleRequest

logger = logging.getLogger(__name__)

async def get_current_uid(
    request: Request,
    db=Depends(get_db)
) -> str:
    auth = request.headers.get("Authorization")
    logger.debug(f"Authorization header: {auth}")
    if not auth or not auth.startswith("Bearer "):
        logger.warning("Authorization header missing or invalid")
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)
    token = auth.split()[1]

    try:
        external_id: str | None = None

        if AUTH_PROVIDER == "supabase":
            try:
                payload = jwt.decode(
                    token,
                    SUPABASE_JWT_SECRET,
                    algorithms=["HS256"],
                    audience="authenticated"
                )
                external_id = payload.get("sub")
            except Exception as e:
                logger.error("Supabase JWT decode error: %s", e)
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail=f"Supabase decode error: {e}"
                )

        elif AUTH_PROVIDER == "firebase":
            try:
                id_info = id_token.verify_firebase_token(
                    token,
                    GoogleRequest(),
                    audience=FIREBASE_PROJECT_ID
                )
                # Token によっては "user_id"、または "sub" にユーザー UID が入っている
                external_id = id_info.get("user_id") or id_info.get("sub")
            except Exception as e:
                logger.error("Firebase token verify error: %s", e)
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Invalid Firebase token"
                )
        else:
            logger.error("Unknown AUTH_PROVIDER: %s", AUTH_PROVIDER)
            raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                                detail="Invalid AUTH_PROVIDER setting")

        if not external_id:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Could not retrieve external_id from token"
            )

        user = await db.users.find_one({
            "external_id": external_id,
            "is_deleted": False
        })
        if not user:
            logger.warning("User not found: external_id=%s", external_id)
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="User not registered"
            )

        return user["uid"]

    except HTTPException:
        # 上記で投げた HTTPException はそのまま
        raise
    except Exception as e:
        logger.error("JWT decode/verify failed: %s", e)
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=f"JWT verify failed: {type(e).__name__}: {e}"
        )


async def get_current_external_id(request: Request) -> str:
    auth = request.headers.get("Authorization")
    if not auth or not auth.startswith("Bearer "):
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)
    token = auth.split()[1]

    if AUTH_PROVIDER == "supabase":
        try:
            payload = jwt.decode(
                token,
                SUPABASE_JWT_SECRET,
                algorithms=["HS256"],
                audience="authenticated"
            )
            return payload["sub"]
        except Exception as e:
            logger.error("Supabase token decode error for external_id: %s", e)
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid Supabase token"
            )

    elif AUTH_PROVIDER == "firebase":
        try:
            id_info = id_token.verify_firebase_token(
                token,
                GoogleRequest(),
                audience=FIREBASE_PROJECT_ID
            )
            return id_info.get("user_id") or id_info.get("sub")
        except Exception as e:
            logger.error("Firebase token verify error for external_id: %s", e)
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid Firebase token"
            )

    else:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Invalid AUTH_PROVIDER setting"
        )



--- FILE: ./ws.py ---

from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Query, status, HTTPException
from jose import jwt
from src.config import SUPABASE_JWT_SECRET, AUTH_PROVIDER, FIREBASE_PROJECT_ID
from src.db import db, redis_client
import asyncio

# Firebase 用
from google.oauth2 import id_token as firebase_id_token
from google.auth.transport.requests import Request as GoogleRequest

router = APIRouter()
active_connections: dict[str, WebSocket] = {}


async def get_uid_from_token(token: str) -> str:
    if not token:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Missing token")

    external_id: str | None = None

    if AUTH_PROVIDER == "supabase":
        try:
            payload = jwt.decode(
                token,
                SUPABASE_JWT_SECRET,
                algorithms=["HS256"],
                audience="authenticated"
            )
            external_id = payload.get("sub")
        except Exception as e:
            # JWT エラーはそのまま伝播させる
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,
                                detail=f"Supabase JWT decode error: {e}")

    elif AUTH_PROVIDER == "firebase":
        try:
            id_info = firebase_id_token.verify_firebase_token(
                token,
                GoogleRequest(),
                audience=FIREBASE_PROJECT_ID
            )
            # Firebase トークンのペイロードには user_id or sub が入っている
            external_id = id_info.get("user_id") or id_info.get("sub")
        except Exception as e:
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,
                                detail=f"Invalid Firebase token: {e}")
    else:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                            detail=f"Unknown AUTH_PROVIDER: {AUTH_PROVIDER}")

    if not external_id:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,
                            detail="Could not retrieve external_id from token")

    user = await db.users.find_one({"external_id": external_id, "is_deleted": False})
    if not user:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,
                            detail="User not registered")

    return user["uid"]


@router.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket, token: str = Query(...)):
    # 初回接続時にトークン検証
    try:
        uid = await get_uid_from_token(token)
    except HTTPException:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        return

    await websocket.accept()
    active_connections[uid] = websocket

    async def cancel_round(room_id: str, reason: str):
        from src.repositories.misc_repo import RoundCacheRepository
        cache = RoundCacheRepository(redis_client)
        await cache.clear(room_id)
        await broadcast_event_to_room(room_id, {
            "type":   "point_round_cancelled",
            "room_id": room_id,
            "reason":  reason,
        })

    try:
        while True:
            data = await websocket.receive_json()
            if not isinstance(data, dict):
                continue

            event_type = data.get("type")
            room_id    = data.get("room_id")

            # ping/pong
            if event_type == "ping":
                await websocket.send_json({"type": "pong"})
                continue

            # 入室／退室
            if event_type in ("enter_room", "leave_room") and room_id:
                # presence 更新
                if event_type == "enter_room":
                    await redis_client.sadd(f"presence:{room_id}", uid)
                else:
                    await redis_client.srem(f"presence:{room_id}", uid)

                # user_entered / user_left をブロードキャスト
                await broadcast_event_to_room(room_id, {
                    "type":      f"user_{'entered' if event_type=='enter_room' else 'left'}",
                    "room_id":   room_id,
                    "uid":       uid,
                })

                # アクティブルラウンドがあればキャンセル
                meta = await redis_client.hgetall(f"points:{room_id}")
                if meta.get("round_id"):
                    await cancel_round(room_id, "User entered/left during active round")
                continue

            # クライアントからの明示的キャンセル
            if event_type == "cancel_point_round" and room_id:
                await cancel_round(room_id, "User cancelled the round")
                continue

            # （他のイベント処理があればここに…）

    except WebSocketDisconnect:
        # 切断時はすべての presence:* から削除
        keys = await redis_client.keys("presence:*")
        for key in keys:
            await redis_client.srem(key, uid)

    finally:
        if active_connections.get(uid) is websocket:
            del active_connections[uid]

async def send_event(uid: str, event: dict):
    ws = active_connections.get(uid)
    if not ws:
        return
    try:
        await ws.send_json(event)
    except Exception:
        if active_connections.get(uid) is ws:
            del active_connections[uid]


async def broadcast_event_to_room(room_id: str, event: dict):
    """room_id の全メンバーに対して send_event を実行"""
    room = await db.rooms.find_one({"room_id": room_id, "is_archived": False})
    if not room:
        return

    for member in room.get("members", []):
        await send_event(member["uid"], event)



